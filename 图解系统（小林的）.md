### 内核空间、用户空间

  内核空间：这个内存空间只有内核程序可以访问
  
  用户空间：这个内存空间专门给应用程序使用
 
 
### 存储器

```
  1、CPU 中的寄存器（处理速度最快）
  
  2、CPU 缓存：L1/L2/L3 三层
  
  -------------------------以上都在CPU 内部，所以读写速度很快----------------------
  
  3、内存：如果断电会丢失
  
  4、硬盘：永久性存储，读写速度相比内存差好几个数量级
```
  我们从图书馆书架取书，把书放到桌子上，再阅读书，我们大脑就会记忆知识点，然后再经过大脑思考，这一系列过程相当于，数据从硬盘加载到内存，再从内存加载到 CPU 的寄存器和 Cache 中，然后再通过 CPU 进行处理和计算
  
# 虚拟内存

### 如何管理虚拟地址与物理地址之间的关系？

  内存分段、内存分页
  
### 内存分段

  虚拟地址：段号+段内偏移
  
  好处：产生连续内存空间
  
  存在问题：会产生内存碎片，内存交换（把占内存空间很大的程序写到磁盘上，再写回来）可以解决，但是磁盘I/O很慢
  
  
### 内存分页

  分页是把整个虚拟和物理内存空间切成⼀段段固定的大小。这样⼀个连续并且尺寸固定的内存空间，我们叫页（Page）。在 Linux 下，每⼀页的大小为 4KB
  
  --页表：存储在内存中的
  
  当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行
  
  存在问题：内存分页机制分配内存的最小单位是一页，即使程序不足一页大小，我们最少只能分配一个页，所以页内会出现内存浪费
  
  如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为换出（Swap Out）。一旦需要的时候，再加载进来，称为换入（Swap In）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。
  
### 段页式内存管理

1、先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制

2、接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页

这样，地址结构就由段号、段内页号和页内位移三部分组成


### 虚拟内存作用

1、可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域

2、由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题

3、页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性

### 内存分配过程

  应用程序通过 malloc 函数申请内存的时候，实际上申请的是虚拟内存，此时并不会分配物理内存
  
  当应用程序读写了这块虚拟内存，CPU 就会去访问这个虚拟内存， 这时会发现这个虚拟内存没有映射到物理内存， CPU 就会产生缺页中断
  
  缺页中断处理函数会看是否有空闲的物理内存，如果有，就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系
  
  如果没有空闲的物理内存，那么内核就会开始进行回收内存的工作，回收的方式主要是两种：直接内存回收和后台内存回收
  
### 内存回收

  --直接内存回收、后台内存回收
  
  直接内存回收：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是同步的，会阻塞进程的执行
  
  后台内存回收：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程异步的，不会阻塞进程的执行
  
  --如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请： ——触发 OOM （Out of Memory）机制
  
  OOM Killer 机制会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置
  
### 哪些内存可以被回收

  文件页：大部分文件页，都可以直接释放内存，以后有需要时，再从磁盘重新读取就可以了，回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存
  
  匿名页：如堆、栈等，这部分内存很可能还要再次被访问，所以不能直接释放内存，它们回收的方式是通过 Linux 的 Swap 机制，Swap 会把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了
  
  --都是基于LRU算法
  
  底层：维护着 active（活跃内存页链表） 和 inactive （不活跃内存页链表）两个双向链表
  
  回收内存的操作基本都会发生磁盘 I/O 的，如果回收内存的操作很频繁，意味着磁盘 I/O 次数会很多，这个过程势必会影响系统的性能，整个系统给人的感觉就是很卡
  
### 解决内存回收带来的性能影响

  1、调整参数，使得每次回收尽量先回收干净的文件页
  
  2、尽早触发后台回收
  
### 如何保护一个进程不被 OOM 杀掉

  如果你想某个进程无论如何都不能被杀掉，那你可以将 oom_score_adj 配置为 -1000
  
### 先Swap，其次才会OOM

将内存数据换出磁盘，又从磁盘中恢复数据到内存的过程，就是 Swap 机制负责的
