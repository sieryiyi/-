# 基础

### 为什么要有 TCP/IP 网络模型？

- 对于同一台设备上的进程间通信，有很多种方式，比如有管道、消息队列、共享内存、信号等方式
- 而对于不同设备上的进程间通信，就需要网络通信
- 而设备是多样性的，所以要兼容多种多样的设备，就协商出了一套通用的网络协议
- 这个网络协议是分层的，每一层都有各自的作用和职责

### TCP/UDP一些细节

- UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以，不过要实现一个商用的可靠 UDP 传输协议，也不是一件简单的事情

- 应用需要传输的数据可能会非常大，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度），就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包

- 端口：当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是端口

### 网络层

如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会再次进行分片

网络号+主机号

### 网络接口层

以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术

### 键入网址到网页显示，期间发生了什么

- 解析 URL，生产 HTTP 请求信息

- 域名解析协议：在发送 HTTP 请求信息之前，还有一项工作需要完成，那就是查询服务器域名对应的 IP 地址，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址

- 从应用层传输到传输层，由TCP或者UDP将数据打包成TCP报文的形式（三次握手），发送到网络层
  - TCP报文头部有一些状态位：例如 SYN 是发起一个连接，ACK 是回复，RST 是重新连接，FIN 是结束连接等
  - TCP 要做流量控制，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力
  - TCP 协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（HTTP 默认端口号是 80， HTTPS 默认端口号是 443）
  - Web服务器是被动的，只有终端客户发起请求时才会响应

- 网络层将接收到的报文打包成IP数据包的形式

- 根据路由表规则，判断下一个转发目的地

- 两点传输 —— MAC，用ARP协议

  - 到了数据链路层，网络包还需要在 IP 头部的前面加上 MAC 头部



- 目前有了 MAC头部+IP头部+TCP头部+数据+帧尾部
  - 首部和尾部的一个重要作用是帧定界，也携带了一些必要的控制信息
  - 网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方
  - 因此，我们需要将数字信息转换为电信号，才能在网线上传输，也就是说，这才是真正的数据发送过程

- 发送出去的网络包会通过交换机到达下一个路由器


  - 交换机工作在 MAC 层，也称为二层网络设备，交换机的端口不具有 MAC 地址，会收下所有发送过来的包

  - 路由器是基于 IP 设计的，俗称三层网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃

  - 完成包接收操作之后，路由器就会去掉包开头的 MAC 头部，重新把下一个目的地的MAC头部加上去


- 数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来，然后一层一层上去

- 拆开TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃

- TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口号
 
- 于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程

- 服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里

- 原样传回去，然后四次挥手断开

### 各层协议（TCP/IP网络协议，四层）

- 应用层，： HTTP、DNS、FTP 等;
- 传输层：TCP/UDP
- 网络层：IP、ICMP
- 网络接口层：ARP

### Linux收发网络包

    进程通过 Socket 接口发送数据包，数据包会被网络协议栈从上到下进行逐层处理后，才会被送到网卡队列中，随后由网卡将网络包发送出去
    
    而在接收网络包时，同样也要先经过网络协议栈从下到上的逐层处理，最后才会被送到应用程序

- 网卡是计算机里的一个硬件，专门负责接收和发送网络包
- 当网卡接收到一个网络包后，会通过 DMA 技术，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer ，这个是一个环形缓冲区，接着就会告诉操作系统这个网络包已经到达

网卡告知操作系统网络包到达的方法

- 最简单的一种方式就是触发中断，也就是每当网卡收到一个网络包，就触发一个中断告诉操作系统
- but，网络包很多，一直中断，CPU就不用干别的了
- 解决方法：NAPI 机制，混合「中断和轮询」（为了解决频繁中断带来的性能开销）
  - 不采用中断的方式读取数据
  - 而是首先采用中断唤醒数据接收的服务程序，然后 poll 的方法来轮询数据
    - 当有网络包到达时，会通过 DMA 技术，将网络包写入到指定的内存地址
    - 接着网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数（需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。接着，发起「软中断」，然后恢复刚才屏蔽的中断）
  - 硬件中断处理函数做的事情很少，主要耗时的工作都交给软中断处理函数了







