https://www.nowcoder.com/discuss/975612   --汇总

https://www.nowcoder.com/discuss/949222   （待看）

# 计算机网络

### HTTP 协议格式 和 HTTP Header

    ①、在应用层

    ②、请求行、请求头部、请求包体；状态行、响应头部、响应包体

    浏览器：发起http请求；服务器：接收http请求




### http怎么保证可靠传输

    http是基于TCP/IP协议的

    1、校验和（保证接收的正确性）：

      发送的数据报的二进制求和取反，如果收到的数据包的校验和有差错，则tcp会丢弃这个报文段并且不会返回确认收到的报文段

    2、序列号（保证有序）：

      tcp会对每一个包进行编号，接收端对数据包按编号进行排序，把有序数组发给应用层

    3、确认应答机制（保证成功接收）：接收方会返回确认接收的报文

    4、超时重传

    5、三次挥手、四次握手（连接管理）

    6、流量控制（控制主机之间的传输速度，防止丢包）

          tcp根据接收端对数据的处理能力，决定发送端的发送速度，如果发送方发送数据的速度过快，导致接收端的缓冲区满，而发送方继续发送，就会造成丢包，继而引起丢包重传等一系列连锁反应。 因此TCP根据接收端的处理能力，来决定发送端的发送速度，这个机制叫做流量控制

    7、拥塞控制（控制网络中的传输，防止丢包）：

          然而如果网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题






### HTTP 中 GET 和 POST 请求的区别

      联系：是http的两种请求方式，底层都是 TCP/IP 协议

      区别：
      ```
      ①、get请求支持后退、刷新，post请求在进行后退的时候，会重新发送请求

      ②、get一般是获取数据，一般用于搜索排序、筛选操作，post一般是提交数据，用于修改和写入数据

      ③、get请求的数据一般会被浏览器主动缓存，post请求不会，所以如果get请求两次都请求相同数据，则第二次的消耗时间会较少

      ④、get请求只能进行url编码，post请求支持多种编码

      ⑤、get请求一般是放在 URL 中的，因此安全性较差，长度也受限（是因为URL的长度被浏览器和服务器限制），而post请求安全性较好，长度不受限

      ⑥、get的效率通常要高一些，因为用get方式请求的时候，浏览器会把http的header和body一起发送出去，成功则返回200，post先发送header，成功则返回100 continue，再发送body，成功返回200

      ⑦、get请求能发送的数据类型是ascll码，post能发更多

      ```
      get 和 post 本质上是TCP/IP连接，但由于http的标准规定和浏览器/服务器的限制，导致在应用过程中体现出一些不同


      -------------------------通常get产生一个TCP数据包，post产生两个数据包--------------------
      ```
      post请求的过程：
      （1）浏览器请求tcp连接（第一次握手）
      （2）服务器答应进行tcp连接（第二次握手）
      （3）浏览器确认，并发送post请求头（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）
      （4）服务器返回100 Continue响应
      （5）浏览器发送数据
      （6）服务器返回200 OK响应
      get请求的过程：
      （1）浏览器请求tcp连接（第一次握手）
      （2）服务器答应进行tcp连接（第二次握手）
      （3）浏览器确认，并发送get请求头和数据（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）
      （4）服务器返回200 OK响应
      也就是说，目测get的总耗是post的2/3左右，这个口说无凭，网上已经有网友进行过测试。

      ```

### 三次握手、四次挥手

      只有三次握手之后才能够保证两台服务器都完全没有问题，各自具备发报和收报能力，防止出现请求超时导致脏连接

      解释：（因为TTL 网络报文的生存时间往往都会超 TCP 请求超时时间，如果两次握手就可以创建连接 ，传输数据并释放连接后，第一个超时的连接请求才到达 B 机器的话，B 机器会以为是 A 创建新连接的请求，然后确认同意创建连接。因为 A 机器的状态不是 SYl_SENT ，所以直接丢弃了 B 的确认数据 ，以致最后只是 B 机器单方面创建连接完毕）

### DNS（域名解析协议）流程

作用：将域名转换为IP地址

TCP/IP中使用的是IP地址和端口号来确定网络上某一台主机上的某一个程序，为什么不用域名来直接进行通信呢？
```
      1. 因为IP地址是固定长度的，IPv4是32位，IPv6是128位，而域名是变长的，不便于计算机处理。
      2. IP地址对于用户来说不方便记忆，但域名便于用户使用
      ```
      就是IP地址是面向主机的，而域名则是面向用户的

      域名服务主要是基于UDP实现的（？）

      主机名.次级域名.顶级域名.根域名：www.baidu.com.root

      DNS解析域名时就是按照层级结构, 从根域名开始逐级向下分级查询
      ```
以www.baidu.com这个域名的查询流程举例

    1、首先查找电脑上的DNS缓存列表，如果有记录，那么直接返回对于IP地址，否则进行下一步；

    2、查找电脑上的HOST文件的映射关系，如果有记录，那么返回对于IP地址，否则进行下一步；

    3、查找互联网线路供应商的本地DNS服务器（即中国电信、中国移动或中国联通），本地DNS服务器先查找自己的缓存记录，如果有记录，那么返回对于IP地址，否则本地DNS服务器向根域名服务器发出请求；

    4、根域名服务器收到请求后，查看是.com顶级域名，于是返回.com顶级域名服务器的IP地址给到本地DNS服务器；

    5、本地DNS服务器收到回复后，向.com顶级域名服务器发起请求；

    6、.com顶级域名服务器收到请求后，查看是.baidu.com次级域名，于是返回.baidu.com次级域名服务器的IP地址给到DNS服务器；

    7、本地DNS服务器收到回复后，向.baidu.com次级域名服务器发起请求；

    8、.baidu.com次级域名服务器收到请求后，查看是自己管理的域名，于是查看域名和IP地址映射表，把www.baidu.com的IP地址返回给本地DNS服务器；

    9、本地DNS服务器收到回复后，向电脑回复域名对应IP地址，并把记录写入本地DNS服务器的缓存里；

    10、电脑收到回复后，使用IP地址访问网站，并把记录写入电脑DNS缓存中。


```

### UDP 在应用层有哪些协议

      1、基于TCP的应用层协议有：HTTP、FTP、SMTP（简单邮件传输协议）、POP3（因为邮件需要保证可靠传输）

      2、基于UDP的应用层协议：DNS（域名系统）、TFTP（简单文件传输协议）、SNMP：简单网络管理协议

### HTTPS 流程 ☆

### https 和 http 区别

      http：超文本传输协议（明文方式发送），是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范，但是存在安全风险！！端口80

      http缺点：使用明文通信，重要内容可能会被窃听；不能验证对方身份；无法验证报文完整性（？）

      -------------------------------

      https：（加密方式发送）是以安全为目标的 HTTP 通道，是 HTTP 的安全版，HTTPS 的安全基础是 SSL，端口443

      https改进：对数据进行加密；身份认证，防止中间人的篡改、攻击



### SSL用的加密方式 ☆

      SSL过程：内容加密，验证身份（验证用户和服务器），保护数据完整性（确保数据在传输过程中不被改变）

      对称加密：加密和解密用的是同一把钥匙，速度更快

      非对称加密：用的是不同的钥匙（公钥，私钥），安全性更高，速度慢

      TLS/SSL 基础概念：给HTTP提供安全支持

### SSL连接过程（四次握手？） ☆

      （1）客户端发起请求

      （2）服务器回应

      （3）客户端回应，并通过前三次握手中的三个随机数生成 “会话秘钥” 

      （4）服务器回应（并接收到会话秘钥）

### ARP协议（地址解析协议）（在数据链路层）

      是用来将IP地址转换为MAC地址

      （每个主机有一个自己的ARP缓冲区）

      1、主机在ARP缓冲区汇总建立一个ARP列表，保存MAC地址和IP地址的对应关系

      2、源主机发送数据时候，先检查ARP列表，如果有对应的，则直接发送

      3、如果没有，则广播查询，其他主机在收到广播消息时，如果IP地址与自己的一致，就把原主机的IP和MAC地址写入缓存，并响应自己的MAC地址

      4、原主机收到响应后，把IP地址和MAC地址的对应关系写入缓存

      5、如果一直没收到响应数据包，则查询失败

### MAC地址

### 拥塞控制（传统方法，最新方法）

    目标：提高网络利用率、降低丢包、保证网络资源对每条数据流的公平性

    传统判断依据：没有按时收到确认报文，认为出现了拥塞，即丢包

    传统方法：慢启动、拥塞避免、快重传、快恢复（拥塞窗口、慢开始门限，假设=16）
        
```
    慢启动：1、2、4....直到到了慢开始门限，改用拥塞避免算法

    拥塞避免：到了慢开始门限后，每次只+1、+1.....

    快重传：避免错误开始执行慢启动算法（因为有时候只是个别报文丢包了，并不是出现了拥塞），接收方立即发送确认，比如m3丢包，则重复发送m2的确认报文，发送端收到3次重复确认后，立刻重传m3，而不是等超时重传

    快恢复：发送方一旦收到3个重复确认，就知道只是丢失了个别报文，于是执行快恢复算法，门限砍成一半，然后执行拥塞避免算法（快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕）
```

    新的方法：丢包判断拥塞的方法，在无线网络、传播时延较大的卫星网络中，将大大降低实际能够达到的传输速度，所以有基于网络测量的算法去判断拥塞：
    
    基于时延的算法：主要以端到端往返时延为参数来调整拥塞控制窗口的大小
    
    fast tcp算法：结合时延和丢包

### 七层协议、传输层有什么协议

### TCP和UDP

      https://blog.csdn.net/weixin_51749544/article/details/124484968?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165996801716781818728648%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165996801716781818728648&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-124484968-null-null.142^v39^new_blog_pos_by_title,185^v2^control&utm_term=tcp%20%E5%92%8C%20udp&spm=1018.2226.3001.4187

      都工作在传输层，用于在程序之间（？）传输数据

      ```
      一包数据可能会被拆成多包发送,如何处理丢包问题，这些数据包到达的先后顺序不同，如何处理乱序问题？

      针对这些问题，tcp协议为每一个连接建立了发送缓冲区

      从建立链接后的第一个字节的序列号为0，后面每个字节的序列号就会增加1，发送数据时，从数据缓冲区取一部分数据组成发送报文，在tcp协议头中会附带序列号和长度，接收端在收到数据后需要回复确认报文，确认报文中的ack等于接受序列号加长度，也就是下包数据发送的起始序列号，这样一问一答的发送方式，能够使发送端确认发送的数据已经被对方收到，发送端也可以发送一次的连续的多包数据，接受端只需要回复一次ack就可以了
      ```


### TCP/IP五层结构

      会话层和表示层合并到了应用层

      如果是四层结构，则是物理层和数据链路层合并成了网络接口层

### 七层模型、对应协议

      -----------物理层、数据链路层、网络层、传输层、会话层、表示层、应用层-----------

      2、数据链路层：地址解析协议ARP

      3、网络层：IPv4/IPv6

      4、传输层：TCP/UDP

      5、会话层：SSL（安全套接字协议）/TLS（安全传输层协议）

      7、应用层：HTTP(超文本传输协议) FTP（文本传输协议） TFTP（简单文件传输协议） SMTP（简单邮件传输协议） DNS（域名系统）  HTTPS（超文本传输安全协议） POP3（邮局协议版本3 ） DHCP（动态主机配置协议）


### UDP应用

    隧道网络，比如：vpn,VXLAN.

### http1.x 和 http2.0的区别

    1、1.0的报文头信息是ascll码，数据体可以是文本或者二进制，而2.0的头信息和数据体都是二进制，统称为帧

    2、单一的长链接（主要优势！）：2.0中，客服端向服务端请求的时候，只会建立一条TCP链接，1.x 则会建立多条（建立多条的原因是防止1.0版本中存在的，请求有序但阻塞的情况，多开几条，少点阻塞），单一的连接可以节省TCP连接的三次握手的时延，与此同时，由于TCP协议的滑动窗口有慢启动的规定，是慢慢变大的，在1.0中，可能刚变大，就新开了个连接从头开始

            即：单一连接避免创建多个TCP连接带来的时延，提高了吞吐量
            
     3、多路复用（在一个TCP连接上并行请求）：和第二条是同一种改动，都是最重要的改动，解决了请求阻塞的问题，具体来说，2.0将每一个分割成帧，
     
     4、头部压缩：1.x中，头部报文带有大量信息且每次都要重复发送，2.0中进行了头部信息压缩，且双方各缓存一张头部信息表，当需要发送的头部信息在表中时，则只需要发送对应序列号即可，节省了发送数据的传输损耗
        
     5、服务端推送：在客服端请求了某个东西时，服务端把可能用到的东西一起发送过去，客户端可以自主选择是否接收，节省了客户端再次请求所需要花费的资源
     
        

### 路由协议


# Python基础知识

### 哈希表的实现

### 迭代器、生成器

1、迭代器

```
    必须类中定义了__iter__和__next__两个方法，且__iter__返回的是类本身，即：self，__next返回的是下一个数据，如果没有下一个数据了，抛出一个异常，这种情况下，这个类叫迭代器类型，用这个类创建的对象叫迭代器对象
    
    （开发中比较少自己创建）
```

2、生成器（函数）

    定义一个函数，函数中出现yield，则称为生成器函数，通过这个创建的时候，会创建一个生成器对象（是一种特殊的迭代器）

3、可迭代对象

    如果一个类中有__iter__方法，且返回一个迭代器对象，则称以这个类创建的对象为可迭代对象
    
    循环可迭代对象的时候，内部会先执行__iter__并获取其返回的迭代器对象，然后后续不断的执行迭代器对象的next方法
    
4、常见数据类型和 ↑ 这些的关系

列表、元组等都是一个可迭代对象，可以放入 for 循环
    
### Python元组和列表

元组：不可变，因此可以作为哈希表、字典的关键字，而列表不行；放弃对元素的增删，换取性能提升，创建元组比列表更省空间，且更快（元组缓存于Python运行时环境，这意味着我们每次使用元组时无须访问内核去分配内存）；多线程并发的时候，元组不需要加锁；可以通过切片等方式间接增加、删除元素，但没有直接的增删方式



### 各种排序算法，冒泡排序的算法实现和复杂度

归并排序（稳定）

### Python垃圾回收机制

### 重载和重写的区别

### 深拷贝、浅拷贝

    深拷贝：拷贝的程度深，自己新开辟了一块内存，将被拷贝内容全部拷贝过来

    浅拷贝：拷贝的程度浅，只拷贝原数据的首地址，然后通过原数据的首地址，去获取内容


### ArrayList和LinkedList有哪些区别

### Python创建多线程的几种方法

    1、Python提供了一个内置模块 threading.Thread，可以很方便地让我们创建多线程
    
    ```
    threading.Thread() 一般接收两个参数：

    线程函数名：要放置线程让其后台执行的函数，由我们自已定义，注意不要加()；

    线程函数的参数：线程函数名所需的参数，以元组的形式传入。若不需要参数，可以不指定。
    ```
    
    2、用类创建多线程
    
    ```
    首先，我们要自定义一个类，对于这个类有两点要求：必须继承 threading.Thread 这个父类；必须复写 run 方法
    
    ```

### hashmap和hashtable的区别，如何保证hashmap线程安全

### 优先队列

### Treemap是什么，底层是什么

### numpy库作用

### is和==的区别

==：比较的是值

is：比较的是地址

### 泛型

```
<T>和<?> 有什么区别？<? super class> 这里的super是什么意思？

```

### 线程的通信方式？

### 线程池参数、拒绝策略、线程池的运行过程、线程池中的线程数什么时候减少

### Python2.0和3.0的区别

### 流式编程？

### 二叉搜索树、平衡二叉树、完全二叉树

### python和C、Java的应用领域有哪些区别


### 单例模式

### 悲观锁和乐观锁

### 迭代器和生成器



### 线性表和链表

线性表：存储内存连续，空间利用率高，查找元素较快，但是插入和删除比较慢

链表：动态分配内存空间，查找较慢，插入和删除较快



### 分布式，分布式算法有了解吗？说不了解就问我是不是对数据库和redis比较了解


### 场景题，现在有很多类，如何确定类的加载顺序？用什么数据结构

### 高并发的情况下，你的项目该如何优化？

### set 和 list


# MySQL知识

### 怎么保证文件数据一致性，hash


### 如何保证redis和MySQL一致性

（问法二：mysql与redis的区别，能不能用redis代替mysql）

    redis不能代替mysql：redis和mysql只能是一种互补
    
    mysql每次请求访问数据库时，都存在着I/O操作，如果反复频繁的访问数据库，速度会很慢；redis数据库就是一款缓存数据库，用于存储使用频繁的数据，这样减少访问数据库的次数，提高运行效率


### MySQL索引底层数据结构（B+树）

https://blog.csdn.net/u010922732/article/details/82992920

### mysql分库分表怎么处理，如果有大表

### 联合索引，联合索引对索引顺序有什么要求吗？

### 数据库实现原理

### 什么是关系型数据库，什么是非关系型数据库，这里的关系指的是什么

    关系数据库：以行和列的方式存储数据，像电子表格一样
    
    非关系数据库：则不以行和列的方式存储数据，使用最适合它所存储的数据类型的存储模型(四种存储模型之一)
    
    （NoSQL提出了另一种理念，以键值来存储，且结构不稳定，每一个元组都可以有不一样的字段，这种就不会局限于固定的结构，可以减少一些时间和空间的开销。使用这种方式，为了获取用户的不同信息，不需要像关系型数据库中，需要进行多表查询。仅仅需要根据key来取出对应的value值即可。）
```
    1、数据集小/中+需要进行密集的读/写操作，就用关系型数据库，需要灵活更改数据类型、海量数据、对事物一致性要求没那么高、对于并发读写能力要求比较高，就用非关系型数据库，比如Radis；
 
    2、在用户看来，一个关系模型的逻辑结构是一张二维表，由行和列组成。这个二维表就叫关系，通俗地说，一个关系对应一张表。
```

### 关系型数据库和非关系型数据库的区别

    1、存储方式☆：关系型是以二维表的数据存储，非关系型是大块存储在一起，根据数据特点选择存储模式，常用的如key-value形式存储

    2、事务（？）：关系型中，如果多张表需要同批次被更新，如果一张更新失败，其他的也会失败

    3、提取：关系型因为是二维表形式存储的，彼此关联，方便提取

    4、结构：关系型得预定义结构，扩展比较麻烦，非关系型是动态结构

    5、扩展方式☆：为了支持更多并发量，SQL数据库是纵向扩展，也就是说提高处理能力，使用速度更快速的计算机，这样处理相同的数据集就更快了；而NoSQL数据库是横向扩展的。非关系型数据存储天然就是分布式的，NoSQL数据库的扩展可以通过给资源池添加更多普通的数据库服务器(节点)（集群？）来分担负载。
    
    总结：非关系型的优点在于处理海量数据和扩展方式



### 事务一致性ACID

    事务是指单个逻辑工作单元执行得一系列操作，要么都做，要么都不做，是不可分割的工作单位，是数据库环境中的的最小工作单元；事务包含了一组操作，这些操作可以是一条SQL语句、一组SQL语句或整个程序。如果其中一个操作不成功，这些操作都不会执行，前面执行的操作也会回滚原状态，用来保证数据的一致性和完整性

### 类加载机制

### 类和对象有什么区别

# Linux知识

### 进程间的通信方式

### 线程间的通信方式



### Linux命令

      （1）777含义：7 表示读取、写入和执行权限，三位是指三个不同的对象：User-文件所属者、Group-文件所属组、Other-其他人（基本上就是全部开放读写执行操作权限）

      （2）修改权限命令：chmod


# 设计模式知识

### 一个系统的qps过高，应该怎么设计? （数据库？）

### 缓存穿透如何处理？

### 高并发如何处理？
