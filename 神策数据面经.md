# 线程、进程

### 1、线程的状态（5种）以及状态间的切换

  1、新建状态：新建了一个线程对象
  
  2、就绪状态：可运⾏，由于其他进程处于运⾏状态⽽暂时停⽌运⾏
  
  3、运行状态：拿到使用权，开始运行
  
  4、阻塞状态：该进程正在等待某⼀事件发⽣（如等待输⼊/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也⽆法运⾏
  
  5、死亡状态
  
切换--------------------------------------------

  1、新建 ----→ 就绪：调用了start方法，进入线程池
  
  2、就绪 ----→ 运行：获取到了cpu使用权，即调度程序选择了这个进程
  
  3、运行 ----→ 就绪：调度程序选择了另一个进程去运行，那么当前这个只能运行转就绪
  
  4、运行 ----→ 阻塞：进程为等待事件而阻塞，调用了sleep/wait/join，或者i/o请求
  
  5、阻塞 ----→ 运行：上述那些结束了（事件完成）
  
  6、运行 ----→ 死亡：线程执行结束或者异常退出
  
  
----------------------挂起状态-----------------

  阻塞挂起：进程在硬盘中并等待某个事件的完成，不占用物理内存
  
  就绪挂起：进程在硬盘中，但只要进入内存，立刻运行
  
  阻塞挂起 ----→ 就绪挂起：事件完成
  

### 2、线程池参数、有哪些常见线程池

  1、corePoolSize：线程池中的常驻核心线程数
  
  2、maximumPoolSize：最大线程容量
  
  3、keepAliveTime：多余的空闲线程存活时间
  
  4、unit：keepAliveTime的单位
  
  5、workQueue：任务队列，被提交但尚未被执行的任务
  
  6、threadFactory：表示生成线程池中工作线程的线程工厂，用户创建新线程，一般用默认即可
  
  7、handler：拒绝策略，表示当线程队列满了并且工作线程大于等于线程池的最大显示数(maxnumPoolSize)时如何来拒绝请求执行的runnable的策略
  
  
  常见线程池：可缓存的线程池、固定大小的线程池、可做任务调度的线程池、单个线程的线程池、足够大小的线程池

### 3、线程池执行、提交任务的过程

### 4、线程池阻塞队列的选择和对比

  阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程
  
  1/2/3：由链表结构组成的有界单向、无界单向、有界双向阻塞队列
  
  4：由数组构成的有界阻塞队列
  
  5、不存元素的阻塞队列
  
  6、支持优先级排序的阻塞队列
  
  7、使用优先级队列实现的无界阻塞队列

### 5、进程和线程的区别

  1、进程是操作系统资源分配的最小单位，而线程是任务的最小单位
  
  一个进程里可以创建多个线程，这里面的线程共享进程的资源
  
  2、进程拥有一个完整的操作系统分配的资源，而线程则是共享（所属进程的）资源，只独享必不可少的资源，比如寄存器和栈，保证相对独立
  
  3、线程能减少并发执行的时间和空间（线程创建快，终止要释放的资源也少，且一个进程里的线程切换更快，因为他们有相同的地址空间，最后，一个进程里的线程通信也快，因为他们共享内存和文件资源）
  
### 6、线程里有什么

  寄存器、栈

### 7、进程和线程的切换的开销

  进程的上下⽂切换：各个进程之间是共享 CPU 资源的，在不同的时候进程之间需要切换，让不同的进程可以在
CPU 执⾏，那么这个⼀个进程切换到另⼀个进程运⾏，称为进程的上下⽂切换

  进程是由内核管理和调度的，所以进程的切换只能发⽣在内核态

  为了保证所有进程可以得到公平调度，CPU 时间被划分为⼀段段的时间⽚，这些时间⽚再被轮流分配给各个进程
  
  线程的上下文切换：当两个线程不是属于同⼀个进程，则切换的过程就跟进程上下⽂切换⼀样，当两个线程是属于同⼀个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据


### 8、进程的调度算法

  非抢占式调度算法：挑选⼀个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调⽤另外⼀个进程，也就是说不会理时钟中断这个事情
  
  抢占式调度算法（cpu时间片方式）：挑选⼀个进程，然后让该进程只运⾏某段时间，如果在该时段结束时，该进程仍然在运⾏时，则会把它挂起，接着调度程序从就绪队列挑选另外⼀个进程
  
  ------------------调度算法原则--------------
  
  确保cpu利用率、系统吞吐量、周转时间（运行+阻塞）、等待时间（就绪状态）、响应时间（主要标准）
  
```
  1、先来先服务 FCFS 算法：适⽤于 CPU 繁忙型作业的系统，⽽不适⽤于 I/O 繁忙型作业的系统
  
  2、最短作业优先调度算法：优先选择运⾏时间最短的进程来运⾏，这有助提高系统的吞吐量
  
  3、高响应比优先调度算法：权衡了短作业和⻓作业
  
  4、时间⽚轮转调度算法（RR）：⼀般来说，时间⽚设为 20ms~50ms
  
  5、最高优先级调度算法：静态优先级、动态优先级
  
  6、多级反馈队列调度算法（MFQ）

```

### 9、优先级调度算法,某进程长时间获取不到资源,怎么解决

  动态调整优先级，等待时间越长，优先级越高

### 10、分配的资源具体是什么 

(CPU执行权 , 内存空间 , 面试官补了个IO)

### 11、什么是线程安全，不安全会出现什么

### 12、多线程中sleep和wait有什么区别

### 13、map如何实现快速的插入同时保证线程安全呢

### 14、进程之间通信的几种方式

  1、管道：实现简单，但通信方式效率低，不适合进程间频繁地交换数据
  
```
  如命令 ps auxf | grep mysq 
  
  上面命令行里的「 | 」竖线就是⼀个管道，它的功能是将前⼀个命令（ ps auxf ）的输出，作为后⼀个命令（ grep mysql ）的输入
  
  管道是单向通信
  
  分类：匿名管道（用完就销毁）、命名管道（也被叫做FIFO，先进先出的传输方式）
  
  匿名管道通信范围：存在父子关系的进程
  
  命名管道：可以在任意不相关的进程间通信
```  

  2、消息队列
```
  A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了 ------------→ 解决了管道效率低下的问题
  
  消息队列⽣命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会⼀直存在，⽽前⾯提到的匿名管道的⽣命周期，是随进程的创建而建立，随进程的结束而销毁
  
  缺点：通信不及时，且通信的数据大小也有限制，不适合较大数据传输
  
  PS：消息队列通信过程中，存在⽤户态与内核态之间的数据拷拷贝开销，因为进程写⼊数据到内核中的消息队列时，会发⽣从⽤户态拷贝数据到内核态的过程，同理另⼀进程读取内核中的消息数据时，会发⽣从内核态拷⻉数据到⽤户态的过程
  
```
  
  3、共享内存
  
    用来解决消息队列中，用户态和内核态的切换的开销问题
  
    原理：拿出⼀块虚拟地址空间来，映射到相同的物理内存中
  
  4、信号量
  
    共享内存带来的问题：是如果多个进程同时修改同⼀个共享内存，很有可能就冲突了，所以需要保护机制
    
    信号量就是充当保护机制，实现进程间的互斥与同步
    
    P 操作、V 操作：P操作会把信号量-1，如果此时信号量＜0，说明资源被占用，进程需要阻塞等待，否则就可以正常执行；V会+1，如果相加后小于等于0，说明当前有阻塞中的进程，会将该进程唤醒运行，否则表明没有进程在阻塞
    
    P操作用于进入共享内存前，V是离开共享后，两个操作成对出现
    
    信号量初始化为期望同时有几个进程在访问共享内存
    
  5、信号
  
    对于异常情况下的⼯作模式，就需要⽤「信号」的方式来通知进程，比如kill-9
    
  6、套接字
  
    用于想跨网络/不同主机上的进程之间的通信的时候
  

### 15、多线程操作HashMap线程安全吗，怎么使其线程安全

  不安全

### 16、一个进程可以没有线程嘛

  不行，光分配资源了没人执行

### 17、进程间同步的方式、线程同步方式

  同步：「操作 A 应在操作 B 之前执⾏」，「操作 C 必须在操作 A 和操作 B 都完成之后才能执⾏」等
  
  线程同步：信号量的P/V操作
  
  线程互斥：锁、信号量的P/V

### 18、进程信号通信方式中，ctrl+c发出的是什么命令，kill后参数是多少

  kill-15

### 19、线程和进程的区别

  线程是计算机调度的基本单位，这些线程共享同一块内存
  
  线程之间可以共享对象、资源，如果有冲突或需要协同，还可以随时沟通以解决冲突或保持同步
  
  进程是通道/命名通道，消息队列，信号量，内存共享
  
  线程则是采用wait()/notify()/notifyAll().

### 20、wait和sleep区别

  sleep：让调用线程进入休眠状态，让出cpu给其他线程，即进入阻塞状态，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间；线程虽然进入休眠，但是对象的锁没有被释放，其他线程依然无法访问这个对象

  wait：让线程进入等待状态，释放了锁，其他线程可以访问此对象

### 21、线程池什么时候回收线程，回收哪些线程

  当存在线程大于固定线程数时，且空闲时间大于空闲线程存活时间的时候，回收这些线程

### 23、启动线程的方法、主线程等待子线程结束的方法







# Linux

https://www.nowcoder.com/discuss/1006468

### 1、Linux怎么关闭进程，原理是什么

  kill-9，其中-9是强制关闭
  
### 2、强制关闭的危害

  导致孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程
  
  正常情况下，子进程是通过父进程创建的，且两者的运行是相互独立的，父进程永远无法预测子进程到底什么时候结束
  

  
### 3、怎么防止孤儿进程

  kill-15，终止信号
  
  想要在Linux中终止一个进程有两种方式，如果是前台进程可以使用Ctrl+C键进行终止；如果是后台进程，那么需要使用kill命令来终止
  
  因为kill -15信号只是通知对应的进程要进行"安全、干净的退出"，程序接到信号之后，退出前一般会进行一些"准备工作"，如资源释放、临时文件清理等等，如果准备工作做完了，再进行程序的终止。
  
  但是，如果在"准备工作"进行过程中，遇到阻塞或者其他问题导致无法成功，那么应用程序可以选择忽略该终止信号。
  
  这也就是为什么我们有的时候使用kill命令是没办法"杀死"应用的原因，因为默认的kill信号是SIGTERM（15），而SIGTERM（15）的信号是可以被阻塞和忽略的。

  
  
### 4、Linux查看文件内容有哪些方法，怎么输出文件的前几行

  head -n 10 文件名

  查看方法：
  
    cat 文件名： 显示文件内容（如果文件内容过多，则只会显示最后一屏幕的内容）
    
    more 文件名： 分页显示文件内容

### 5、Linux文件权限有哪些，怎么控制，九位字母代表什么

  linux 使用9位字母来表示权限，r代表读权限，w代表写权限，x代表执行权限
  
  9位字母三位三位区分：1-3 表示用户的权限，4-6 表示group用户的权限，7-9 表示其他用户的权限
  
  控制方法：r代表二进制中的100，即4，w代表010，x代表001，因此如果三种用户都可读可写可执行，那么每一个人的权限就是4+2+1=7，就是chomd 777
  
  （group用户是用户组）
  

### 6、Linux怎么创建文件，怎么创建文件夹，怎么查看进程占用资源

  创建文件夹：mkdir 文件夹名
  
  创建文件：touch 文件名
  
  查看进程占用资源：top命令

### 7、top命令，df命令

  top命令：监控的最小单位是进程，能够实时显示系统各个进程的资源占用情况
  
  df命令：用来检查 linux 服务器的文件系统的磁盘空间占用情况

### 8、linux命令查询文件夹占用的磁盘空间大小

  df命令

### 9、查找进程ID的命令

### 10、查看系统内存，磁盘使用情况，IO占用，查看IO占用端口

  看内存：top命令
  
  看磁盘：df命令
  
  看I/O：

### 11、kill一定能杀死一个进程吗

  不能，有僵尸进程
  
  当一个进程调用 exit 命令结束自己的生命时，其实它并没有真正的被销毁，内核只是释放了该进程的所有资源，包括打开的文件、占用的内存等，但是留下一个称为僵尸进程的数据结构
  
  这个结构保留了一定的信息（包括进程号 the process ID，退出状态，运行时间），这些信息直到父进程通过 wait()/waitpid() 才能释放
  
  但如果父进程没有这么做的话，会产生什么后果呢？此时，子进程虽然已经退出了，但是在系统进程表中还为它保留了一些退出状态的信息，如果父进程一直不取得这些退出信息的话，这系统进程表就将一直被占用
  
  系统进程表是一项有限资源，如果系统进程表被僵尸进程耗尽的话，系统就可能无法创建新的进程
  
  僵尸进程虽然不占有任何内存空间，但如果父进程不调用 wait() / waitpid() 的话，那么保留的信息就不会释放，其进程号就会一直被占用，而系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害。
  
  
  解决方法：把产生大量僵尸进程的父进程kill-9，让这些僵尸进程变成孤儿进程
  

### 12、Linux 看磁盘大小， 查看进程占用的端口，查看指定服务的进程端口号

  磁盘剩余大小：df -hl
  
  查看进程占用的端口：lsof -i:端口号
  

### 13、linux文件怎么读尾10行

  tail -n 10 文件名

### 14、发现进程端口占用了你怎么处理

  kill

### 15、发现程序一直在FullGC有什么好的解决办法？

### 16、如何终止日志



# 操作系统

### 1、虚拟内存

  操作系统是如何管理虚拟地址与物理地址之间的关系？内存分页（页号+页内偏移）和内存分段（段号+段内偏移量）
  
  分段的好处就是能产⽣连续的内存空间，但是会出现内存碎⽚和内存交换的空间太大的问题
  
  分页：把整个虚拟和物理内存空间切成⼀段段固定尺⼨的大小，这样⼀个连续并且尺⼨固定的内存空间，我们叫⻚（Page）。在 Linux 下，每⼀⻚的⼤⼩为 4KB

### 2、页面置换算法

  当出现缺页异常，需调入新页面而内存已满时，置换算法选择被置换的页面

  FIFO/LRU

### 3、LRU怎么实现

  哈希表和双向链表，为什么要用这个
  
  哈希表查询节点速度很快，而双向链表插入删除很快
  
### 4、虚拟地址大小跟什么有关系

### 5、七层网络模型及其对应协议

### 6、TCP/UDP区别及其使用场景

### 7、TCP怎么实现可靠性

### 8、滑动窗口完整流程

### 9、计算机网络各种状态访问码代表什么

### 10、动态代理缺点

### 11、浏览器发数据为什么不用80端口

  80是接受数据用的

### 12、https证书为什么可信

### 13、https中间人攻击是什么？怎么防御？

  

### 14、FTP协议哪一层

  应用层

### 15、tcp建立链接需要知道什么吗（ip+端口号）？端口号的作用是什么，他存在的意义是什么

  tcp的连接是两个进程间的通信，而数据链路层的是通过硬件地址来区分的，所以我认为端口号就是为了区分同一计算机上的不同进程，端口号本质上就是一个整型。tcp和udp端口号可以相同，不冲突。

### 16、操作系统从用户态到内核态都有哪些方式?

  系统调用、出现异常、外设中断

### 17、如果服务器挂了，然后又好了，客服端再给服务器发消息的时候会再一次三次握手吗？

  看挂了后再重启的时间是否超过等待时间，如果没超过，直接继续传输，如果超过，重新建立连接  

### 18、https状态：206/401

206：范围请求成功

401：表示发送的请求需要有通过 HTTP 认证的认证信息

### 19、ip地址有哪些保留地址

  A类里1个，B类里16个，C类里255个，使用保留地址的网络只能在内部进行通信

### 20、http端口号是啥

  http：80

  https：443

### 21、http有没有基于udp的实例

### 22、负载均衡，类似淘宝的流量是怎么做的

  当一台服务器的性能达到极限时，我们可以使用服务器集群来提高网站的整体性能
  
  那么，在服务器集群中，需要有一台服务器充当调度者的角色，用户的所有请求都会首先由它接收，调度者再根据每台服务器的负载情况将请求分配给某一台后端服务器去处理
  
  调度策略：随机分配、轮询
  
  http重定向均衡方法

### 23、UDP是全双工的吗

### 24、http无状态

  HTTP无状态协议，是指协议对于交互性场景没有记忆能力 
  
  缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大

### 25、cookie与session区别

  让服务器有记忆能力之Cookie、Session
  
  Cookie：实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容
  
  Session：是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上
  
  客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了

### 26、一个HTTP请求包含什么？

  各种协议、请求头、请求报文

### 27、阻塞和非阻塞

  阻塞和非阻塞通常用来形容多线程间的相互影响。比如一个线程占用了临界区资源，那么其他所有需要这个而资源的线程就必须在这个临界区中进行等待。等待会导致线程挂起，这种情况就是阻塞。此时，如果占用资源的线程一直不愿意释放资源，那么其他所有阻塞在这个临界区上的线程都不能工作。非阻塞的意思与之相反，它强调没有一个线程可以妨碍其他线程执行。所有的线程都会尝试不断前向执行

### 28、拆包、粘包



# 数据结构

### 1、HashMap底层怎么实现的

  底层是由“数组+链表+红黑树”组成
  
  非线程安全、无序

### 2、HashMap添加的一个元素过程

  1、计算key的哈希值
  
  2、如果此时数组非空，则初始化，再计算索引位置，不然直接计算索引位置
  
  3、索引位置没有节点的话，创建节点，如果有节点了，分为红黑树节点还是链表节点，如果是红黑树，插入后再进行平衡调整，如果是链表，直接插入，如果到达阈值8，则转红黑树
  
  4、如果节点达到了扩容阈值，则扩容


### 4、跳表（时间复杂度是多少）、位图

      （redis用的是跳表而不是红黑树）

  跳表：可以快速查找、删除、插入、实现简单，跟红黑树都是一样量级的，查询、插入、删除的时间复杂度都是O(logn)，空间复杂度是O（n）
  
  时间复杂度 = 索引的高度 * 每层索引遍历元素的个数
  
  思想：用空间换时间
  
  -----------结合了链表和二分查找的思想
  
  1、由原始链表和一些通过“跳跃”生成的链表组成
  
  2、第0层是原始链表，越上层“跳跃”的越高，元素越少
  
  3、上层链表是下层链表的子序列
  
  4、查找时从顶层向下，不断缩小搜索范围
  
  （这里有必要提出的是，每隔两个节点往上提升一层建立索引只是理想情况，实际上是通过随机层数来实现的）
  
  

### 5、堆的应用场景、队列的应用场景

  堆：top k问题、大数据量日志统计搜索问题（哈希表+堆）

```
  有10亿（或者50G）的查询关键词，需要进行排序求Top K，类似在搜索引擎框中提示
  
  不能一次加载到内存中时：把数据分散到若干文件中，对每一个文件求top k，再将这若干个文件的top k合并到一起再求top k
```

  队列应用场景：

### 6、能不能在创建HashMap的时候通过某些设置减少HashMap中哈希冲突的概率

  链表法，开放地址法，扰动函数法（就是把16位高位异或搞进来），红黑树

### 7、什么是hashcode？一般怎么用？

  hashcode就是采用哈希函数计算出来的值，一般为了用于快速存取数据时候使用的。

### 8、hashmap是线程安全的吗？如何实现一个线程安全的hashmap呢？

  hashmap不是线程安全的。三种办法吧，1、手动进行同步。2、采用hashtable。3、采用更好的concurrenthashmap。

### 9、Hashmap 升级成红黑树的阈值（阈值：8），降级回链表的阈值（阈值：7）

  对于插入操作，默认情况是使用链表，当同一个索引位置的节点在新增后=9个的时候（即：原本是8），如果此时数组长度≥64，则会触发链表转红黑树节点，如果＜64，则不会转，而是会扩容
  
  （即：此时＜64 说明数据量还不大，没必要转红黑树，所以扩容就行）
  
  对于移除操作，当同一个位置的节点在移除后达到6个（阈值6），且该位置是红黑树节点，则会触发转链表
  
-------------为什么阈值为8----------------------

  a.红黑树节点大小约为链表节点的2倍，在节点太少时，红黑树的查找性能优势并不明显，付出2倍空间的代价不值得
  
  b.理想情况下，链表中节点个数为 8 时的概率非常非常低，且到节点为 8 的时候，红黑树查询优势会开始展现

-------------为什么回转链表节点用的是6-------------

  如果我们设置节点多于8个转红黑树，少于8个就马上转链表，当节点个数在 8 徘徊时，就会频繁进行红黑树和链表的转换，造成性能的损耗
  
  

### 10、为什么要升级成红黑树

  即：从数组+链表实现的哈希表 -----→ 到数组+链表+红黑树的哈希表
 
  主要是为了提升在 hash 冲突严重时（链表过长）的查找性能，使用链表的查找性能是 O(n)，而使用红黑树是 O(logn)

### 11、红黑树

  是一种自平衡的二叉搜索树
```
  a.节点是红色或者黑色的，根节点是黑色的，每个叶子结点都是黑色的空结点（NULL结点）
  
  b.每个红色结点的两个子结点都是黑色(从每个叶子到根的所有路径上不能有两个连续的红色结点)
  
  c.从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点！！！
```
  --经过以上的限制，红黑树从根到叶子结点的最长路径不会超过最短路径的2倍
  
  --当插入/删除节点的时候，红黑树结构可能会被打破，此时需要[旋转]or[变色]，旋转又分左旋转和右旋转

### 12、哈希表的重要属性

  a.大小容量size，哈希表已经存储的结点个数，默认初始容量是16，（HashMap 的容量必须是 2 的 N 次方，HashMap 会根据我们传入的容量计算一个大于等于该容量的最小的2的N次方，例如传 9，容量为16）
  
  b.扩容阈值threshold，当个数达到这个值的时候，触发扩容（threshold 还会被用来存初始化时的容量）
  
  c.负载因子loadFactor：扩容阈值 = 容量 × 负载因子，负载因子默认值0.75
  
### 13、为什么哈希表的容量要是2的N次方

  计算索引位置的公式为：(n - 1) & hash，当 n 为 2 的 N 次方时，n - 1 为低位全是 1 的值，此时任何值跟 n - 1 进行 & 运算的结果为该值的低 N 位，达到了和取模同样的效果，实现了均匀分布
  
  实际上，这个设计就是基于公式：x mod 2^n = x & (2^n - 1)，因为 & 运算比 mod 具有更高的效率

### 14、计算 key 的 hash 值，是怎么设计的？

  拿到 key 的 hashCode，并将 hashCode 的高16位和 hashCode 进行异或（XOR）运算，得到最终的 hash 值
  
  让高16位参与运算原因：主要是为了在 table 的长度较小的时候，让高位也参与运算，并且不会有太大的开销，如当n=8时，由于 n - 1 是 0000 0111，所以结果只取决于 hash 值的低3位，无论高位怎么变化，结果都是一样的

### 15、扩容

  扩容后要重新计算每个数据的索引位置，方法：e.hash & oldCap == 0

### 16、为什么redis要用跳表而不是红黑树

  1、跳表实现比红黑树更简单
  
  2、跳表区间查找效率更高一点
  
  3、跳表插入or删除，只需要修改前后节点的指针（因为它本身还是个链表），而红黑树需要旋转或者变色来维持平衡
  
  
### 17、set底层

  要求有序、不重复：红黑树










# MySQL 

### 1、一条sql语句的执行过程

  连接器：建立连接，管理连接、校验用户身份
  
  解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型
  
  执行 SQL：执行 SQL 共有三个阶段：
  
      预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列
      
      优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；
      
      执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端

### 2、binlog是在哪实现的、在哪个阶段写入

  Mysql主要是依靠 redo log 和 binlog 这两个日志来保证数据不丢失的
  
  binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；
  
  

### 3、b+树一个结点的容量

  B+树一个节点的大小设为一页或页的倍数最为合适。因为如果一个节点的大小 < 1页，那么读取这个节点的时候其实读取的还是一页（16K），这样就造成了资源的浪费
  
  InnoDB的B+树中，非叶子节点存的是key + 指针；叶子节点存的是数据行
  
  对于叶子节点，如果一行数据大小为1k，那么一页就能存16条数据
  
  对于非叶子节点，如果key使用的是bigint，则为8字节，指针在mysql中为6字节，一共是14字节，则16k能存放 16 * 1024 / 14 = 1170 个索引指针
  
  于是可以算出，对于一颗高度为2的B+树，根节点存储索引指针节点，那么它有1170个叶子节点存储数据，每个叶子节点可以存储16条数据，一共 1170 x 16 = 18720 条数据
  
  而对于高度为3的B+树，就可以存放 1170 x 1170 x 16 = 21902400 条数据（两千多万条数据），也就是对于两千多万条的数据，我们只需要高度为3的B+树就可以完成，通过主键查询只需要3次IO操作就能查到对应数据
  
  所以在 InnoDB 中B+树高度一般为3层时，就能满足千万级的数据存储，所以一个节点为1页，也就是16k是比较合理的

### 5、左连接、右连接、内连接、全连接

  where和on有什么区别：on是建立关联关系在生成临时表时候执行，where是在临时表生成后对数据进行筛选的
  
  内连接：select A.name,B.class from A inner join B on A.id=B.A_id 
  
  左连接：select A.name,B.class from A left join B on A.id-B.A_id
  
  右连接：select A.name,B.class from A right join B on A.id=B.A_id
  
  全连接：select A.name,B.class from A full join B on A.id=B.A_id
  
  
  

### 6、怎么加索引

  CREATE TABLE table_name ADD PRIMARY KEY (index_column_1)

### 7、B+树和红黑树区别

  一个是多叉树，一个是二叉树，一个支持区间查找一个不行
  
  

### 8、哪些适合做主键

  不重复的、对于用户无意义的、不会被修改的
  
  例子：自增id，或者UUID算法生成的一串数字（可能会用到诸如网卡MAC地址，IP，主机名，进程ID等信息以保证其独立性）

### 9、现在有一些索引，发现查询效率底，原因可能有什么？

### 10、B+树分裂原理

### 11、sql: 发布文章最多的用户的名字
```
  select 名字 from 表名 group by 名字 order by count(*) desc limit 1
```
### 12、存储引擎

innoDB、MyISAM、

### 13、redo日志

  在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘，当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态



### 15、聚合

  聚合操作指的是在数据查找基础上对数据的进一步整理筛选行为，如max，min

### 16、修改表的字段

  alter table 表名 modify 字段 其他

### 17、数据定义语言DDL和数据操纵语言DML

DML(Data Manipulation Language)数据操纵语言：如insert,delete,update,select等

DDL(Data Definition Language)数据定义语言：如Create,Alter和Drop.

### 18、分库分表，主从复制，读写分离，水平与垂直切分

### 19、缓存击穿、缓存穿透

### 20、数据库的特性：ACID

  原子性、一致性、隔离性、持久性

### 21、怎么实现一个join，时间复杂度是多少？怎么优化



### 22、举一个死锁的例子

  

### 23、日志

  undo log（回滚日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和 MVCC（多版本并发控制）
  
  redo log（重做日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复；
  
  binlog （归档日志）：是 Server 层生成的日志，主要用于数据备份和主从复制；

  缓冲池（Buffer Pool）：来提高数据库的读写性能

### 24、主从复制

  MySQL 的主从复制依赖于 binlog ，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上

  在完成主从复制之后，你就可以在写数据时只写主库，在读数据时只读从库，这样即使写请求会锁表或者锁记录，也不会影响读请求的执行
  
  redo log 影响主库的数据，binlog 影响从库的数据，所以 redo log 和 binlog 必须保持一致才能保证主从数据一致。
  
### 25、为什么要两阶段提交

  MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决
  
  「准备（Prepare）阶段」和「提交（Commit）阶段」
  
### 26、MySQL 磁盘 I/O 很高，有什么优化的方法

  事务在提交的时候，需要将 binlog 和 redo log 持久化到磁盘，那么如果出现 MySQL 磁盘 I/O 很高的现象，我们可以通过控制以下参数，来 “延迟” binlog 和 redo log 刷盘的时机，从而降低磁盘 I/O 的频率




# Python

### 1、垃圾回收GC原理

### 2、怎么解决引用计数算法的循环引用问题（Java独有的？）

  强弱引用：若 A 强引用了 B，那 B 引用 A 时就需使用弱引用，当判断是否为无用对象时仅考虑强引用计数是否为 0，不关心弱引用计数的数量
  
### 3、垃圾回收器都有哪些（Java独有的？）

  一共七种
  
  serial收集器
  
  parallel new收集器
  
  Parallel Scavenge 收集器
  
  CMS收集器
  
  serial old收集器
  
  parallel old 收集器
  
  G1收集器
  
  serial系列采用单线程进行数据收集，parallel采用多线程进行数据收集。parallel scavenge收集器则更强调吞吐量，吞吐量是用于用户线程的时间/CPU时间。G1和CMS收集器则均采用并行处理的过程，加快了垃圾收集的效率。但G1可以有效处理浮动垃圾，而CMS不行。

### 4、为什么垃圾回收的时候需要stop the world

  一致性、防止垃圾浮动
  


### 6、重写和重载的区别

  重写：在子类里想要修改父类的某种方法，即重写
  
  重载：是指在类中有两个或两个以上的同名方法，但各个方法中的参数类型、参数个数或顺序不同

### 7、哈希冲突解决方法

  1、链地址
  
  2、再哈希法：提供多个哈希函数，如果第一个哈希函数计算出来的key的哈希值冲突了，则使用第二个哈希函数计算key的哈希值
  
  3、建立公共溢出区：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表
  
  
  4、改变负载因子
  
  5、开放寻址法
  
### 8、堆的实现

### 9、优先队列

### 10、判定一个对象是不是垃圾

  当对象的引用数量为 0，说明这个对象已经成为「垃圾」了

### 11、并查集时间复杂度

  并查集的时间复杂度为 O(logn)

### 12、最小生成树算法有哪些，克鲁斯卡尔算法 ,复杂度

### 14、队列和双端队列的区别，底层用什么实现，是否连续存储

  队列：先进先出
  
  优先队列（堆的实现）：优先队列在添加数据的过程中，会根据这个元素的优先级将其放到合适的位置上
  
  双端队列：可以同时在表前端和后端进行添加或删除操作

### 15、为set设置get的默认值，元组和列表的区别

### 16、Python的继承

  继承就是让类和类之间产生父子关系，子类可以拥有父类的静态属性和方法




# 手撕

### 1、实现包含max函数的栈，要求O（1）

  思路：本题需要重新自定义 push,pop,top,min,max 方法，使得能够通过 min/max 方法随时得到当前栈中的最小、最大元素
  
```
时间复杂度O（1）的方法：
    
    用两个栈，栈 A 正常压入值 x ，栈 B 将 x 与栈顶的元素比较，如果x大，压入x，如果原本的栈顶大，则再压入一次原本栈顶的值（类似dp操作？）
  
    --全部压入完成后，栈 B 的栈顶即为最大值
  
空间复杂度为O（1）的方法：

    维护一个最大值max，在push方法中，比较当前的待压元素与max的差值，如果待压元素＞max，则更新max，并把差值压入栈中，如果不大于，就直接把差值压入栈中

```


### 2、有10T的数据和10台容量为1T的电脑，我要怎么存储和查询

### 3、最大的k个数，复杂度是多少，能继续优化吗，如果空间不够怎么办

  创建一个大小为K=100的小堆，调整好，然后从K开始拿十万个数据一个一个跟堆头比较，如果比堆头大，就入堆，然后调整成最小堆，一直循环到第N=100000个数据

### 4、50GB数据，但是只有1GB内存，如何进行一个排序的操作

  1、把50GB分割成比如100块，每块0.5GB（不直接每块1GB是防止读入内存后，内存一点空间都没了）
  
  2、顺序将每块0.5读入内存并快速排序
  
  3、把排序好的数据存回磁盘
  
  4、从这100块里，每一块里取其前百分之一的数据放入内存，并排序这些数据，临时写入基于内存的输出缓冲区，当缓冲区写满后，写入硬盘上的最终文件，并清空缓冲区；当这100块里有任何一个数据处理完成时，就读入这一块数据的下一坨数据
  
  （输出缓冲区：当使用printf/puts/putchar等函数显示数据时，并不会直接显示在屏幕上，而是先放入输出缓存区中（提高程序运行效率），当满足某些条件下才会显示出来）

### 5、有一个数据量比较大的文件，每一行都是有序的url，想要去重有什么方法？内存放不下

  将文件分为n个小文件，原始文件的url进行hash，得到值value，相同的url的文件具有相同的value，所以会被分配到同一个小文件上，顺序将小文件读入内存并去重，再读回去  
  

### 6、有100亿数据，保存前10000个，该怎么做？内存太大了怎么做？

（有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M，要求返回频数最高的100个词）

  Step1：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件(记为f0,f1,…,f4999)中，这样每个文件大概是200k左右，如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M;
  
  Step2：对每个小文件，统计每个文件中出现的词以及相应的频率(可以采用trie树/hash_map等)，并取出出现频率最大的100个词(可以用含100个结点的最小堆)，并把100词及相应的频率存入文件，这样又得到了5000个文件;
  
  Step3：把这5000个文件进行归并(类似与归并排序);




### 7、给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url?

  Step1：遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件(记为a0,a1,…,a999，每个小文件约300M);
  
  Step2:遍历文件b，采取和a相同的方式将url分别存储到1000个小文件(记为b0,b1,…,b999);
  
  （巧妙之处：这样处理后，所有可能相同的url都被保存在对应的小文件(a0vsb0,a1vsb1,…,a999vsb999)中，不对应的小文件不可能有相同的url。然后我们只要求出这个1000对小文件中相同的url即可）
  
  Step3：求每对小文件ai和bi中相同的url时，可以把ai的url存储到hash_set/hash_map中。然后遍历bi的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了

### 8、现有海量日志数据保存在一个超级大的文件中，该文件无法直接读入内存，要求从中提取某天出访问百度次数最多的那个IP

  Step1：从这一天的日志数据中把访问百度的IP取出来，逐个写入到一个大文件中;

  Step2：注意到IP是32位的，最多有2^32个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件;

  Step3：找出每个小文中出现频率最大的IP(可以采用hash_map进行频率统计，然后再找出频率最大的几个)及相应的频率;

  Step4：在这1000个最大的IP中，找出那个频率最大的IP，即为所求。





# 神经网络

### 1、神经网络怎么工作

### 2、梯度下降/反向传播

### 3、求导是什么？怎么求导？偏导呢？有什么区别？



