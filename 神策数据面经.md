# 线程、进程

### 1、线程的状态（5种）以及状态间的切换

  1、新建状态：新建了一个线程对象
  
  2、就绪状态：线程对象创建后，其他线程调用了该对象的start方法。该状态的线程位于可运行线程池中，变得可以运行，只等待获取cpu的使用权
  
  3、运行状态：拿到使用权，开始运行
  
  4、阻塞状态：线程因为某种原因放弃CPU使用权，暂时停止运行，直到线程进入就绪状态，才有机会转为运行状态
  
  5、死亡状态
  
切换--------------------------------------------

  1、新建 ----→ 就绪：调用了start方法，进入线程池
  
  2、就绪 ----→ 运行：获取到了cpu使用权
  
  3、运行 ----→ 就绪：
  
  4、运行 ----→ 阻塞：调用了sleep/wait/join，或者i/o请求
  
  5、阻塞 ----→ 运行：上述那些结束了
  
  6、运行 ----→ 死亡：线程执行结束或者异常退出
  

### 2、线程池参数、有哪些常见线程池

  

### 3、线程池执行、提交任务的过程

### 4、线程池阻塞队列的选择和对比

### 5、进程和线程的区别

  进程是操作系统资源分配的最小单位，而线程是任务的最小单位
  
  一个进程里可以创建多个线程，这里面的线程共享进程的资源
  
### 6、线程里有什么

### 7、进程和线程的切换的开销

### 8、进程的调度算法

### 9、优先级调度算法,某进程长时间获取不到资源,怎么解决

  (超时时间调整优先级)

### 10、分配的资源具体是什么 

(CPU执行权 , 内存空间 , 面试官补了个IO)

### 11、什么是线程安全，不安全会出现什么

### 12、多线程中sleep和wait有什么区别

### 13、map如何实现快速的插入同时保证线程安全呢

### 14、进程之间通信的几种方式

--共享内存的通信方式有什么好处

### 15、多线程操作HashMap线程安全吗，怎么使其线程安全

### 16、一个进程可以没有线程嘛

  不行，光分配资源了没人执行

### 17、进程间同步的方式

### 18、进程信号通信方式中，ctrl+c发出的是什么命令，kill后参数是多少

  kill-15

### 19、线程和进程的区别

  线程是计算机调度的基本单位，这些线程共享同一块内存，线程之间可以共享对象、资源，如果有冲突或需要协同，还可以随时沟通以解决冲突或保持同步。进程是通道/命名通道，消息队列，信号量，内存共享。线程则是采用wait()/notify()/notifyAll().

### 20、wait和sleep区别

  wait()释放资源而.sleep()不释放资源；.wait()需要先获取锁，原因是wait()的原理是先将线程放到阻塞队列，再释放对应的锁。


### 21、线程池 什么时候回收线程，回收哪些线程

### 22、阻塞队列怎么实现，有哪些阻塞队列

### 23、启动线程的方法、主线程等待子线程结束的方法







# Linux

https://www.nowcoder.com/discuss/1006468

### 1、Linux怎么关闭进程，原理是什么

  kill-9，其中-9是强制关闭
  
### 2、强制关闭的危害

  导致孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程
  
  正常情况下，子进程是通过父进程创建的，且两者的运行是相互独立的，父进程永远无法预测子进程到底什么时候结束
  

  
### 3、怎么防止孤儿进程

  kill-15，终止信号
  
  想要在Linux中终止一个进程有两种方式，如果是前台进程可以使用Ctrl+C键进行终止；如果是后台进程，那么需要使用kill命令来终止
  
  因为kill -15信号只是通知对应的进程要进行"安全、干净的退出"，程序接到信号之后，退出前一般会进行一些"准备工作"，如资源释放、临时文件清理等等，如果准备工作做完了，再进行程序的终止。
  
  但是，如果在"准备工作"进行过程中，遇到阻塞或者其他问题导致无法成功，那么应用程序可以选择忽略该终止信号。
  
  这也就是为什么我们有的时候使用kill命令是没办法"杀死"应用的原因，因为默认的kill信号是SIGTERM（15），而SIGTERM（15）的信号是可以被阻塞和忽略的。

  
  
### 4、Linux查看文件内容有哪些方法，怎么输出文件的前几行

  head -n 10 文件名

  查看方法：
  
    cat 文件名： 显示文件内容（如果文件内容过多，则只会显示最后一屏幕的内容）
    
    more 文件名： 分页显示文件内容

### 5、Linux文件权限有哪些，怎么控制，九位字母代表什么

  linux 使用9位字母来表示权限，r代表读权限，w代表写权限，x代表执行权限
  
  9位字母三位三位区分：1-3 表示用户的权限，4-6 表示group用户的权限，7-9 表示其他用户的权限
  
  控制方法：r代表二进制中的100，即4，w代表010，x代表001，因此如果三种用户都可读可写可执行，那么每一个人的权限就是4+2+1=7，就是chomd 777
  
  （group用户是用户组）
  

### 6、Linux怎么创建文件，怎么创建文件夹，怎么查看进程占用资源

  创建文件夹：mkdir 文件夹名
  
  创建文件：touch 文件名
  
  查看进程占用资源：top命令

### 7、top命令，df命令

  top命令：监控的最小单位是进程，能够实时显示系统各个进程的资源占用情况
  
  df命令：用来检查 linux 服务器的文件系统的磁盘空间占用情况

### 8、linux命令查询文件夹占用的磁盘空间大小

  df命令

### 9、查找进程ID的命令

### 10、查看系统内存，磁盘使用情况，IO占用，查看IO占用端口

  看内存：top命令
  
  看磁盘：df命令
  
  看I/O：

### 11、kill一定能杀死一个进程吗

  不能，有僵尸进程
  
  当一个进程调用 exit 命令结束自己的生命时，其实它并没有真正的被销毁，内核只是释放了该进程的所有资源，包括打开的文件、占用的内存等，但是留下一个称为僵尸进程的数据结构
  
  这个结构保留了一定的信息（包括进程号 the process ID，退出状态，运行时间），这些信息直到父进程通过 wait()/waitpid() 才能释放
  
  但如果父进程没有这么做的话，会产生什么后果呢？此时，子进程虽然已经退出了，但是在系统进程表中还为它保留了一些退出状态的信息，如果父进程一直不取得这些退出信息的话，这系统进程表就将一直被占用
  
  系统进程表是一项有限资源，如果系统进程表被僵尸进程耗尽的话，系统就可能无法创建新的进程
  
  僵尸进程虽然不占有任何内存空间，但如果父进程不调用 wait() / waitpid() 的话，那么保留的信息就不会释放，其进程号就会一直被占用，而系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害。
  
  
  解决方法：把产生大量僵尸进程的父进程kill-9，让这些僵尸进程变成孤儿进程
  

### 12、Linux 看磁盘大小， 查看进程占用的端口，查看指定服务的进程端口号

  磁盘剩余大小：df -hl
  
  查看进程占用的端口：lsof -i:端口号
  

### 13、linux文件怎么读尾10行

  tail -n 10 文件名

### 14、发现进程端口占用了你怎么处理

  kill

### 15、发现程序一直在FullGC有什么好的解决办法？

### 16、如何终止日志



# 操作系统

### 1、虚拟缓存

### 2、页面置换算法

### 3、LRU怎么实现

  哈希表和双向链表，为什么要用这个
  
### 4、虚拟地址大小跟什么有关系

### 5、七层网络模型及其对应协议

### 6、TCP/UDP区别及其使用场景

### 7、TCP怎么实现可靠性

### 8、滑动窗口完整流程

### 9、计算机网络各种状态访问码代表什么

### 10、动态代理缺点

### 11、80端口，为什么不用

### 12、https证书为什么可信

### 13、https中间人攻击是什么？怎么防御？

### 14、FTP协议哪一层

### 15、tcp建立链接需要知道什么吗（ip+端口号）？端口号的作用是什么，他存在的意义是什么

### 16、操作系统从用户态到内核态都有哪些方式?

### 17、如果服务器挂了，然后又好了，客服端再给服务器发消息的时候会再一次三次握手吗？

  

### 18、https状态：206/401

### 19、ip地址有哪些保留地址

### 20、http端口号是啥(

### 21、http有没有基于udp的实例

### 22、负载均衡，类似淘宝的流量是怎么做的

### 23、UDP是全双工的吗

### 24、http无状态

### 25、cookie与session区别

### 26、一个HTTP请求包含什么？

### 27、阻塞和非阻塞




# 数据结构

### 1、HashMap底层怎么实现的

  底层是由“数组+链表+红黑树”组成
  
  非线程安全、无序

### 2、HashMap添加的一个元素过程

  1、计算key的哈希值
  
  2、如果此时数组非空，则初始化，再计算索引位置，不然直接计算索引位置
  
  3、索引位置没有节点的话，创建节点，如果有节点了，分为红黑树节点还是链表节点，如果是红黑树，插入后再进行平衡调整，如果是链表，直接插入，如果到达阈值8，则转红黑树
  
  4、如果节点达到了扩容阈值，则扩容


### 4、跳表（时间复杂度是多少）、位图

      （redis用的是跳表而不是红黑树）

  跳表：可以快速查找、删除、插入、实现简单，跟红黑树都是一样量级的，查询、插入、删除的时间复杂度都是O(logn)，空间复杂度是O（n）
  
  时间复杂度 = 索引的高度 * 每层索引遍历元素的个数
  
  思想：用空间换时间
  
  -----------结合了链表和二分查找的思想
  
  1、由原始链表和一些通过“跳跃”生成的链表组成
  
  2、第0层是原始链表，越上层“跳跃”的越高，元素越少
  
  3、上层链表是下层链表的子序列
  
  4、查找时从顶层向下，不断缩小搜索范围
  
  （这里有必要提出的是，每隔两个节点往上提升一层建立索引只是理想情况，实际上是通过随机层数来实现的）
  
  

### 5、堆的应用场景、队列的应用场景

  堆：top k问题、大数据量日志统计搜索问题（哈希表+堆）

```
  有10亿（或者50G）的查询关键词，需要进行排序求Top K，类似在搜索引擎框中提示
  
  不能一次加载到内存中时：把数据分散到若干文件中，对每一个文件求top k，再将这若干个文件的top k合并到一起再求top k
```

  队列应用场景：

### 6、能不能在创建HashMap的时候通过某些设置减少HashMap中哈希冲突的概率

  链表法，开放地址法，扰动函数法（就是把16位高位异或搞进来），红黑树

### 7、什么是hashcode？一般怎么用？

  hashcode就是采用哈希函数计算出来的值，一般为了用于快速存取数据时候使用的。

### 8、hashmap是线程安全的吗？如何实现一个线程安全的hashmap呢？

  hashmap不是线程安全的。三种办法吧，1、手动进行同步。2、采用hashtable。3、采用更好的concurrenthashmap。

### 9、Hashmap 升级成红黑树的阈值（阈值：8），降级回链表的阈值（阈值：7）

  对于插入操作，默认情况是使用链表，当同一个索引位置的节点在新增后=9个的时候（即：原本是8），如果此时数组长度≥64，则会触发链表转红黑树节点，如果＜64，则不会转，而是会扩容
  
  （即：此时＜64 说明数据量还不大，没必要转红黑树，所以扩容就行）
  
  对于移除操作，当同一个位置的节点在移除后达到6个（阈值6），且该位置是红黑树节点，则会触发转链表
  
-------------为什么阈值为8----------------------

  a.红黑树节点大小约为链表节点的2倍，在节点太少时，红黑树的查找性能优势并不明显，付出2倍空间的代价不值得
  
  b.理想情况下，链表中节点个数为 8 时的概率非常非常低，且到节点为 8 的时候，红黑树查询优势会开始展现

-------------为什么回转链表节点用的是6-------------

  如果我们设置节点多于8个转红黑树，少于8个就马上转链表，当节点个数在 8 徘徊时，就会频繁进行红黑树和链表的转换，造成性能的损耗
  
  

### 10、为什么要升级成红黑树

  即：从数组+链表实现的哈希表 -----→ 到数组+链表+红黑树的哈希表
 
  主要是为了提升在 hash 冲突严重时（链表过长）的查找性能，使用链表的查找性能是 O(n)，而使用红黑树是 O(logn)

### 11、红黑树

  是一种自平衡的二叉搜索树
```
  a.节点是红色或者黑色的，根节点是黑色的，每个叶子结点都是黑色的空结点（NULL结点）
  
  b.每个红色结点的两个子结点都是黑色(从每个叶子到根的所有路径上不能有两个连续的红色结点)
  
  c.从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点！！！
```
  --经过以上的限制，红黑树从根到叶子结点的最长路径不会超过最短路径的2倍
  
  --当插入/删除节点的时候，红黑树结构可能会被打破，此时需要[旋转]or[变色]，旋转又分左旋转和右旋转

### 12、哈希表的重要属性

  a.大小容量size，哈希表已经存储的结点个数，默认初始容量是16，（HashMap 的容量必须是 2 的 N 次方，HashMap 会根据我们传入的容量计算一个大于等于该容量的最小的2的N次方，例如传 9，容量为16）
  
  b.扩容阈值threshold，当个数达到这个值的时候，触发扩容（threshold 还会被用来存初始化时的容量）
  
  c.负载因子loadFactor：扩容阈值 = 容量 × 负载因子，负载因子默认值0.75
  
### 13、为什么哈希表的容量要是2的N次方

  计算索引位置的公式为：(n - 1) & hash，当 n 为 2 的 N 次方时，n - 1 为低位全是 1 的值，此时任何值跟 n - 1 进行 & 运算的结果为该值的低 N 位，达到了和取模同样的效果，实现了均匀分布
  
  实际上，这个设计就是基于公式：x mod 2^n = x & (2^n - 1)，因为 & 运算比 mod 具有更高的效率

### 14、计算 key 的 hash 值，是怎么设计的？

  拿到 key 的 hashCode，并将 hashCode 的高16位和 hashCode 进行异或（XOR）运算，得到最终的 hash 值
  
  让高16位参与运算原因：主要是为了在 table 的长度较小的时候，让高位也参与运算，并且不会有太大的开销，如当n=8时，由于 n - 1 是 0000 0111，所以结果只取决于 hash 值的低3位，无论高位怎么变化，结果都是一样的

### 15、扩容

  扩容后要重新计算每个数据的索引位置，方法：e.hash & oldCap == 0

### 16、为什么redis要用跳表而不是红黑树

  1、跳表实现比红黑树更简单
  
  2、跳表区间查找效率更高一点
  
  3、跳表插入or删除，只需要修改前后节点的指针（因为它本身还是个链表），而红黑树需要旋转或者变色来维持平衡
  
  











# MySQL 

### 1、一条sql语句的执行过程

### 2、binlog是在哪实现的、在哪个阶段写入

### 3、b+树一个结点的容量

### 4、容量怎么确定

### 5、左连接、右连接、内连接、全连接

where和on有什么区别

### 6、怎么加索引

### 7、B+树和红黑树区别

### 8、哪些适合做主键

### 9、现在有一些索引，发现查询效率底，原因可能有什么？

### 10、B+树分裂原理

### 11、sql: 发布文章最多的用户的名字

### 12、存储引擎

### 13、redo日志

### 14、数据库连接方式

### 15、聚合

### 16、修改表的字段

### 17、DDL和DML

### 18、分库分表，主从复制，读写分离，水平与垂直切分

### 19、缓存击穿、缓存穿透

### 20、数据库的特性：ACID

### 21、怎么实现一个join，时间复杂度是多少？怎么优化

### 22、举一个死锁的例子





# Python

### 1、垃圾回收GC原理

### 2、怎么解决引用计数算法的循环引用问题

  强弱引用
  
### 3、垃圾回收器都有哪些

  一共七种
  
  serial收集器
  
  parallel new收集器
  
  Parallel Scavenge 收集器
  
  CMS收集器
  
  serial old收集器
  
  parallel old 收集器
  
  G1收集器
  
  serial系列采用单线程进行数据收集，parallel采用多线程进行数据收集。parallel scavenge收集器则更强调吞吐量，吞吐量是用于用户线程的时间/CPU时间。G1和CMS收集器则均采用并行处理的过程，加快了垃圾收集的效率。但G1可以有效处理浮动垃圾，而CMS不行。

### 4、为什么垃圾回收的时候需要stop the world

  一致性、防止垃圾浮动
  
### 5、G1

### 6、重写和重载的区别

### 7、哈希冲突解决方法

  负载因子
  
### 8、堆的实现

### 9、优先队列

### 10、判定一个对象是不是垃圾，列举几个垃圾回收器

### 11、并查集时间复杂度

### 12、最小生成树算法有哪些，克鲁斯卡尔算法 ,复杂度

### 13、指针与引用的区别

### 14、队列和双端队列的区别，底层用什么实现，是否连续存储

### 15、为set设置get的默认值，元组和列表的区别

### 16、Python的继承




# 手撕

### 1、实现包含max函数的栈，要求O（1）

  思路：本题需要重新自定义 push,pop,top,min,max 方法，使得能够通过 min/max 方法随时得到当前栈中的最小、最大元素
  
```
时间复杂度O（1）的方法：
    
    用两个栈，栈 A 正常压入值 x ，栈 B 将 x 与栈顶的元素比较，如果x大，压入x，如果原本的栈顶大，则再压入一次原本栈顶的值（类似dp操作？）
  
    --全部压入完成后，栈 B 的栈顶即为最大值
  
空间复杂度为O（1）的方法：

    维护一个最大值max，在push方法中，比较当前的待压元素与max的差值，如果待压元素＞max，则更新max，并把差值压入栈中，如果不大于，就直接把差值压入栈中

```


### 2、有10T的数据和10台容量为1T的电脑，我要怎么存储和查询

### 3、最大的k个数，复杂度是多少，能继续优化吗，如果空间不够怎么办

  创建一个大小为K=100的小堆，调整好，然后从K开始拿十万个数据一个一个跟堆头比较，如果比堆头大，就入堆，然后调整成最小堆，一直循环到第N=100000个数据

### 4、50GB数据，但是只有1GB内存，如何进行一个排序的操作

  1、把50GB分割成比如100块，每块0.5GB（不直接每块1GB是防止读入内存后，内存一点空间都没了）
  
  2、顺序将每块0.5读入内存并快速排序
  
  3、把排序好的数据存回磁盘
  
  4、从这100块里，每一块里取其前百分之一的数据放入内存，并排序这些数据，临时写入基于内存的输出缓冲区，当缓冲区写满后，写入硬盘上的最终文件，并清空缓冲区；当这100块里有任何一个数据处理完成时，就读入这一块数据的下一坨数据
  
  （输出缓冲区：当使用printf/puts/putchar等函数显示数据时，并不会直接显示在屏幕上，而是先放入输出缓存区中（提高程序运行效率），当满足某些条件下才会显示出来）

### 5、有一个数据量比较大的文件，每一行都是有序的url，想要去重有什么方法？内存放不下

  将文件分为n个小文件，原始文件的url进行hash，得到值value，相同的url的文件具有相同的value，所以会被分配到同一个小文件上，顺序将小文件读入内存并去重，再读回去  
  

### 6、有100亿数据，保存前10000个，该怎么做？内存太大了怎么做？

（有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M，要求返回频数最高的100个词）

  Step1：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件(记为f0,f1,…,f4999)中，这样每个文件大概是200k左右，如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M;
  
  Step2：对每个小文件，统计每个文件中出现的词以及相应的频率(可以采用trie树/hash_map等)，并取出出现频率最大的100个词(可以用含100个结点的最小堆)，并把100词及相应的频率存入文件，这样又得到了5000个文件;
  
  Step3：把这5000个文件进行归并(类似与归并排序);




### 7、给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url?

  Step1：遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件(记为a0,a1,…,a999，每个小文件约300M);
  
  Step2:遍历文件b，采取和a相同的方式将url分别存储到1000个小文件(记为b0,b1,…,b999);
  
  （巧妙之处：这样处理后，所有可能相同的url都被保存在对应的小文件(a0vsb0,a1vsb1,…,a999vsb999)中，不对应的小文件不可能有相同的url。然后我们只要求出这个1000对小文件中相同的url即可）
  
  Step3：求每对小文件ai和bi中相同的url时，可以把ai的url存储到hash_set/hash_map中。然后遍历bi的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了

### 8、现有海量日志数据保存在一个超级大的文件中，该文件无法直接读入内存，要求从中提取某天出访问百度次数最多的那个IP

  Step1：从这一天的日志数据中把访问百度的IP取出来，逐个写入到一个大文件中;

  Step2：注意到IP是32位的，最多有2^32个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件;

  Step3：找出每个小文中出现频率最大的IP(可以采用hash_map进行频率统计，然后再找出频率最大的几个)及相应的频率;

  Step4：在这1000个最大的IP中，找出那个频率最大的IP，即为所求。





# 神经网络

### 1、神经网络怎么工作

### 2、梯度下降/反向传播

### 3、求导是什么？怎么求导？偏导呢？有什么区别？



