### mMySQL和Redis有什么区别

- MySQL是关系型数据库，Redis是非关系型数据库
- MySQL的数据是存储在磁盘里的，因此存取数据伴随着磁盘I/O，而Redis是一种内存型数据库，存取数据更快
- 因此Redis更适合高并发、高性能场景

### 关系数据库、非关系型数据库

- 数据存储方式不同：
  - 关系型数据库是一个结构化的数据库，创建在关系模型（二维表格模型）基础上
  - 关系型数据天然就是表格式的，因此存储在数据表的行和列中
  - 数据表可以彼此关联协作存储，也很容易提取数据
  - 非关系型数据不适合存储在数据表的行和列中，而是大块组合在一起
  - 非关系型数据通常存储在数据集中，就像文档、键值对或者图结构


### epoll是什么？poll和epoll区别？分别适用于什么场景？

epoll是一种I/O多路复用技术

select：
- 使用select的应用程序用多路复用器，把我们想要监听的文件描述符分成三类（可读，可写，异常）
- 一次性全部传给Linux内核，然后内核轮询所有文件描述符
- 应用程序拿到返回值后，要自己遍历所有文件描述符，找出哪些被内核标记为有事件就绪
poll：
- poll的调用接口更简单一些
- 他没有把监控的事件分为三类（可读，可写，异常），而是统一用一个变量来表示
- poll能够监视的事件种类远不止三种

epoll：
- 实现epoll的核心是红黑树
- 内核中创建的内核事件表其实就是一颗红黑树
- 我们往内核事件表中注册的每个事件，都对应红黑树中的一个节点


### 双向循环链表是什么？

### 怎么中序遍历一颗二叉树？（递归加迭代）

迭代逻辑（使用栈）

```

    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        
        cur=root
        stack=[]
        ans=[]
        while cur or stack:
            while cur:
                stack.append(cur)
                cur=cur.left
            node=stack.pop()
            ans.append(node.val)
            cur=node.right
            
        return ans

```


### 归并排序，时间复杂度，空间复杂度，稳定性

空间复杂度：O（1）



### linux根目录下有哪些文件夹？都有什么用？

- bin：存放常用命令
- var：存放那些经常被修改的文件，包括各种日志、数据文件
- etc：存放配置文件

### 从左上角开始，顺时针往中心遍历一个二维数组，可以的话用两个线程实现，分别输出奇数圈和偶数圈

### 如何先序遍历一颗二叉树

```
def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        #迭代
        if not root:
            return []
        stack=[root]
        ans=[]
        while stack:
            node=stack.pop()
            if not node:
                continue
            ans.append(node.val)
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)
        return ans
```


### Hash冲突处理方法？

- 链地址法
- 再哈希法
- 建立公共溢出区
- 开放定址法

### 二叉搜索树的插入、查询、删除操作说说，以及时间复杂度是多少？

平均情况：
- 插入、删除、查找：O（logN）
最坏情况：
- 插入、删除、查找：O（N）

### 贪心算法取得最优解的条件是什么？

每次的局部最优解必须在全局最优解序列中，否则不可能到达全局最优（？）

局部最优解能决定全局最优解



### 贪心算法和动态规划有什么区别？

贪心算法是动态规划的一个特例，动态规划是贪心算法的泛化


- 贪心算法：不从整体最优上加以考虑，它所做的选择只是在某种意义上的局部最优解
- dp：将待求解的问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解



### 说说线程是怎么工作的？

### 说说数据库查询是什么样的？

执行顺序：

- from
- where
- group by
- having
- select
- order by
- limit

### 说说TCP有哪些机制，挑一个你最熟悉的机制说说

### 几乎有序的数组排序 https://www.cnblogs.com/laydown/p/12819624.html

### Redis的持久化机制？

RDB快照、AOF持久化

### Aof持久化如果文件满了怎么办？

- 触发AOF重写机制

### 二叉树的层序遍历

### 快速排序

要能过leetcode912，注意其中一个坑爹用例，专门坑我这种傻乎乎的大冤种）和小于等于 K 的最长二进制子序列（leetcode2311）

### 给出一排价值不同的物品，不限定取多少个，但是每次都不能取上一次取得物品的左右边的物品，问最大取得物品价值是多少？

### 面向对象三大特征

### 操作系统的float编码

### socket网络编程，以及linux是如何实现的

### 为什么操作系统除法比乘法慢


### 手写小根堆，并且堆排序

### 进程间通信方式

### 乐观锁与悲观锁的区别

### 分布式锁的方案

Q：为什么要使用分布式锁

A：针对于同一个接口，如果在同一时间有大量请求来访问，如果这些需要对数据库中的同一条数据进行修改，这条就可能出现不可控制的问题

红锁：红锁本质上就是使用多个Redis做锁






### 死锁的原因

### 给一个坐标系，给一个圆，问圆里包含多少点（暴力），能否优化（可以算四分之一）

优化方法：向量法只需要比较点与圆心差向量的模长是否小于等于半径即可

abs(m -x + (n-y)*(1j)) <= r:

### redis主从复制

### 死锁怎么解决




























