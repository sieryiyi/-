--- 整体复习---

# 索引

作用：以空间换时间，加快查找速度，类似于书本的目录，避免一页一页去查找某一页

### BST树、AVL树、B树、B+树

1、BST树：二叉排序树，即左节点 < 根 < 右节点
```
  优点：查询时间比链表快，是O(nlogn)

  缺点：如果插入的节点的值越来越大或者越来越小，则会退化为一条链表
```

2、AVL树：平衡二叉树，在BST树的基础上，其任意节点的左右子树高度差不超过1
```
  优点：不会退化为一条链表，且时间复杂度是O(nlogn)
```

3、B树：多叉树，一般称为 M阶B树，M是分叉个数
```
  --------B树特点-------------

  每个节点的值都是按照递增次序排序的，左小右大
  
  根节点的子节点个数为[2,M]，其他非叶节点的子节点个数为[ceil(M/2),M]，ceil是向上取整
  
  每个非叶节点的值（索引）个数=子节点个数-1

  --------B树优缺点-------------

  优点：B树每一个节点都包含key和value，相比于B+树，离根节点近的元素能更快被查找到

  缺点：不利于范围查找（区间查找），B树查找区间，还是得一个一个查
```

4、B+树
```
  ------------B+树特点---------------

  内部有两种节点：索引节点、叶子节点

  B+树的索引结点只用于索引，所有的数据都保存在B+树的叶子结点中；B树则是所有结点都会保存数据

  B+树的叶子结点都会被连成一条双向链表，方便区间查找

  B树的所有索引值是不会重复的，而B+树非叶子结点的索引值，最终一定会全部出现在叶子结点中

  ------------B+树优缺点---------------
  
  优点：
  
  查找区间时，可以直接通过链表进行查找
  
  中间不存储数据，因此相同大小的磁盘空间，可以容纳更多的节点元素
  
  在数据量相同的情况下，B+树的结构比B树更加“矮胖”，因此查询的IO次数也更少

  B树的查找性能并不稳定（最好情况只查询根节点，最坏情况是查找叶子节点），而B+树的每一次查找都是稳定的
```

### 磁盘读取

是上述B+树的解释

```
  和内存相比，从磁盘中读取数据的速度会慢上百倍千倍甚至万倍，所以，我们应当尽量减少从磁盘中读取数据的次数

  从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读；如果我们能把尽量多的数据放进磁盘块中，那一次磁盘读取操作就会读取更多数据，那我们查找数据的时间也会大幅度降低
  
  如果我们用树这种数据结构作为索引的数据结构，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块；
  
  在树的数据结构中，每个节点称为页，页就是我们上面说的磁盘块，在 MySQL 中数据读取的基本单位都是页，所以我们这里叫做页更符合 MySQL 中索引的底层数据结构
  
  B+树之所以这么做是因为在数据库中页的大小是固定的，InnoDB 中页的默认大小是 16KB。
  如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的 IO 次数又会再次减少，数据查询的效率也会更快
  
```

### MySQL的索引

默认用B+树作为索引类型：

  1、主键索引：如果有主键，用主键当索引
  
  2、如果没有主键，选一列不包含null的做索引，都没有，就自动生成一个隐藏自增id列作为索引key，这俩都属于二级索引
  
```
  PS：主键索引：叶节点存放的是实际数据，二级索引：存放的是主键值
  
  select * from product where product_no = '0002';        --这条就是拿二级索引查询
  
  过程：通过二级索引，或者叶子结点中存的主键值，再去主键索引对应的B+树中查询具体数据，即需要查两次
  
  注意：当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引查，如：
  
  select id from product where product_no = '0002';          --这条语句本身查的就是主键值，此时只需要查询一次B+树
  
  上述在二级索引的B+树中就能查询到结果的过程叫：覆盖索引
```
```
  B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，所以B+Tree 相比于 B 树和二叉树来说，最大的优势：在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次
```

### 索引分类

  按数据结构：B+索引，hash索引
  
  按物理存储分：主键索引、二级索引
  
  按字段特性分：主键索引、唯一索引、普通索引、前缀索引
  
  按字段个数分：单列索引、联合索引
  
### 什么时候需要索引？什么时候不需要？

  优点：提高查询速度
  
  缺点：需要占用存储空间；创建索引和维护索引要耗费时间（数据量越大耗费越大）；降低增删改的效率，因为每次表内变动，B+树为了维护自己的有序性，都要一起跟着动态维护
  
  适用场景：
```
  1、字段有唯一性的，比如商品编码

  2、经常用where查询的字段，可以提高整张表的查询速度，如果不止一个字段，可以建立联合索引

  3、经常需要group by或者order by的字段，这样在查询过程中不需要再次排序，因为B+树叶节点本身有序
```

  不适用场景：
```
  1、where / order by / group by中用不到的字段（即：列）不用创建索引

  2、数据很少的时候，不用建立索引

  3、经常更新的字段，不要建立索引
```

### 优化索引的方法

  1、前缀索引优化
```
  优点：减小索引字段的大小，进而提高索引页里面存储的值的多少，有助于提高查询效率

  缺点：排序order by不能使用前缀索引；无法把前缀索引用作覆盖索引
```

  2、覆盖索引优化
  
    从二级索引中查询得到记录，而不需要去主键索引树中再次查找，即：避免回表操作，或者覆盖索引操作
    
    方法：比如如果要查询商品的名称、价格，则可以建立联合索引：（商品ID，名称，价格）
    
    好处：不需要查询出包含整个记录的所有信息，也就减少了I/O操作
    
  3、主键索引最好是自增的
  
    （MySQL里好像只要设置为主键就默认自增？）
    
    如果是自增的，每次往页面里插入新的数据，其实就相当于添加到最后面的位置，如果页面满了，就开个新页面，类似列表的append？append的效率肯定比insert高？
    
    PS：主键的字段长度最好也小点，这样二级索引叶子节点存储的空间也就小了
    
  4、索引最好设置为 NOT NULL
  
    NULL是个无意义的值，但还是会占用物理空间
  
  5、防止索引失效

    当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效


# 事务

