--- 整体复习---

# 索引

作用：以空间换时间，加快查找速度，类似于书本的目录，避免一页一页去查找某一页

### BST树、AVL树、B树、B+树

1、BST树：二叉排序树，即左节点 < 根 < 右节点
```
  优点：查询时间比链表快，是O(nlogn)

  缺点：如果插入的节点的值越来越大或者越来越小，则会退化为一条链表
```

2、AVL树：平衡二叉树，在BST树的基础上，其任意节点的左右子树高度差不超过1
```
  优点：不会退化为一条链表，且时间复杂度是O(nlogn)
```

3、B树：多叉树，一般称为 M阶B树，M是分叉个数
```
  --------B树特点-------------

  每个节点的值都是按照递增次序排序的，左小右大
  
  根节点的子节点个数为[2,M]，其他非叶节点的子节点个数为[ceil(M/2),M]，ceil是向上取整
  
  每个非叶节点的值（索引）个数=子节点个数-1

  --------B树优缺点-------------

  优点：B树每一个节点都包含key和value，相比于B+树，离根节点近的元素能更快被查找到

  缺点：不利于范围查找（区间查找），B树查找区间，还是得一个一个查
```

4、B+树
```
  ------------B+树特点---------------

  内部有两种节点：索引节点、叶子节点

  B+树的索引结点只用于索引，所有的数据都保存在B+树的叶子结点中；B树则是所有结点都会保存数据

  B+树的叶子结点都会被连成一条双向链表，方便区间查找

  B树的所有索引值是不会重复的，而B+树非叶子结点的索引值，最终一定会全部出现在叶子结点中

  ------------B+树优缺点---------------
  
  优点：
  
  查找区间时，可以直接通过链表进行查找
  
  中间不存储数据，因此相同大小的磁盘空间，可以容纳更多的节点元素
  
  在数据量相同的情况下，B+树的结构比B树更加“矮胖”，因此查询的IO次数也更少

  B树的查找性能并不稳定（最好情况只查询根节点，最坏情况是查找叶子节点），而B+树的每一次查找都是稳定的
```

### 磁盘读取

是上述B+树的解释

```
  和内存相比，从磁盘中读取数据的速度会慢上百倍千倍甚至万倍，所以，我们应当尽量减少从磁盘中读取数据的次数

  从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读；如果我们能把尽量多的数据放进磁盘块中，那一次磁盘读取操作就会读取更多数据，那我们查找数据的时间也会大幅度降低
  
  如果我们用树这种数据结构作为索引的数据结构，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块；
  
  在树的数据结构中，每个节点称为页，页就是我们上面说的磁盘块，在 MySQL 中数据读取的基本单位都是页，所以我们这里叫做页更符合 MySQL 中索引的底层数据结构
  
  B+树之所以这么做是因为在数据库中页的大小是固定的，InnoDB 中页的默认大小是 16KB。
  如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的 IO 次数又会再次减少，数据查询的效率也会更快
  
```

### MySQL的索引

默认用B+树作为索引类型：

  1、主键索引：如果有主键，用主键当索引
  
  2、如果没有主键，选一列不包含null的做索引，都没有，就自动生成一个隐藏自增id列作为索引key，这俩都属于二级索引
  
```
  PS：主键索引：叶节点存放的是实际数据，二级索引：存放的是主键值
  
  select * from product where product_no = '0002';        --这条就是拿二级索引查询
  
  过程：通过二级索引，或者叶子结点中存的主键值，再去主键索引对应的B+树中查询具体数据，即需要查两次
  
  注意：当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引查，如：
  
  select id from product where product_no = '0002';          --这条语句本身查的就是主键值，此时只需要查询一次B+树
  
  上述在二级索引的B+树中就能查询到结果的过程叫：覆盖索引
```
```
  B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，所以B+Tree 相比于 B 树和二叉树来说，最大的优势：在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次
```

### 索引分类

  按数据结构：B+索引，hash索引
  
  按物理存储分：主键索引、二级索引
  
  按字段特性分：主键索引、唯一索引、普通索引、前缀索引
  
  按字段个数分：单列索引、联合索引
  
### 什么时候需要索引？什么时候不需要？

  优点：提高查询速度
  
  缺点：需要占用存储空间；创建索引和维护索引要耗费时间（数据量越大耗费越大）；降低增删改的效率，因为每次表内变动，B+树为了维护自己的有序性，都要一起跟着动态维护
  
  适用场景：
```
  1、字段有唯一性的，比如商品编码

  2、经常用where查询的字段，可以提高整张表的查询速度，如果不止一个字段，可以建立联合索引

  3、经常需要group by或者order by的字段，这样在查询过程中不需要再次排序，因为B+树叶节点本身有序
```

  不适用场景：
```
  1、where / order by / group by中用不到的字段（即：列）不用创建索引

  2、数据很少的时候，不用建立索引

  3、经常更新的字段，不要建立索引
```

### 优化索引的方法

  1、前缀索引优化
```
  优点：减小索引字段的大小，进而提高索引页里面存储的值的多少，有助于提高查询效率

  缺点：排序order by不能使用前缀索引；无法把前缀索引用作覆盖索引
```

  2、覆盖索引优化
  
    从二级索引中查询得到记录，而不需要去主键索引树中再次查找，即：避免回表操作，或者覆盖索引操作
    
    方法：比如如果要查询商品的名称、价格，则可以建立联合索引：（商品ID，名称，价格）
    
    好处：不需要查询出包含整个记录的所有信息，也就减少了I/O操作
    
  3、主键索引最好是自增的
  
    （MySQL里好像只要设置为主键就默认自增？）
    
    如果是自增的，每次往页面里插入新的数据，其实就相当于添加到最后面的位置，如果页面满了，就开个新页面，类似列表的append？append的效率肯定比insert高？
    
    PS：主键的字段长度最好也小点，这样二级索引叶子节点存储的空间也就小了
    
  4、索引最好设置为 NOT NULL
  
    NULL是个无意义的值，但还是会占用物理空间
  
  5、防止索引失效

    当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效


# 事务

  MySQL 事务主要用于处理操作量大，复杂度高的数据： 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行
  
  事务是一个不可分割的工作逻辑单元，在数据库系统上执行并发操作时，事务是最小的控制单元，适用于多用户同时操作的数据库系统的场景；只要有一个操作没成功，整个事务都将回滚到事务开始前

### 并发和并行

  并发：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行
```
    并发的程序之间有制约关系：直接制约是某个程序需要另一个程序的计算结果，间接制约是多个程序竞争某个资源
    
    并发程序在执行中是走走停停、断续推进的，任一时刻点上只有一个程序在运行
    
    1.串行是指两个或两个以上程序按顺序发生
    2.并行是指两个或以上程序在同一时间点发生
    3.并发是指两个或两个以上程序在同一时间段发生
    
    通俗一点就是你打游戏打到一半你妈妈叫你吃饭了，你打完游戏再去吃饭，这就是串行一件一件事情完成。如果你手速够快你可以放个技能吃口饭推个塔吃口饭，在游戏和吃饭之间来回切换丝毫不影响你送人头这就是并发。再如果你是大神一只手操作另一只手吃饭同时进行不耽误你carry队友这就是并行。
    
```
  并行：指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的

### 并发可能存在的问题

  1、线程安全问题：在缺少合理的同步机制的情况下，多线程的执行顺序是不可预知的；为了让多线程程序的行为具有可预测性，共享变量的访问必须被合理地协调，使得一个线程对该变量的访问不会干扰到另一个线程
  
  2、活跃性问题：例如线程 A 在等待一个资源，该资源被线程 B 排他性地占有了，并且线程 B 永远不释放该资源，那么线程 A 必须永远等待下去
  
  性能风险：在多线程程序中调度器经常需要临时挂起一个线程，运行另一个线程，这被称为上下文切换；上下文切换会造成很大的开销，保存和恢复执行上下文、调度线程都需要时间，降低了多线程的性能

### 事务的运行流程举例

  比如：转账操作
  
  在转账操作前先开启事务，等所有数据库操作执行完成后，才提交事务，对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，如果中途发生发生中断或错误，那么该事务期间对数据库所做的修改将会被回滚到没执行该事务之前的状态
  
### 事务特性

  1、原子性：事务要么成功，要么失败，没有中间态
  
  2、一致性：指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态，比如转账前A有100，B有100，总共200，转账后，A没钱了，B有200，总计200，不能出现总计不是200的情况
  
  3、隔离性 ☆ ：数据库允许多个并发事务同时对其数据进行读写和修改的能力，彼此之间互不影响，一个事务内部的操作对并发的其他事务是具有隔离性的
  
  4、持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失
  
### 隔离性（重点）

  1、脏读：一个事务读取到了另一个事务没有提交的数据
  
  2、不可重复读：前后读取的数据不一致，即：在一个事务内多次读取同一个数据，出现前后两次读到的数据不一样的情况
  
  3、幻读：前后读取的记录数量不一致，即：在一个事务内，多次查询某个符合查询条件的「记录数量」，出现前后两次查询到的记录数量不一样的情况
  
  --------以上都会对事务的一致性产生影响----------
  
  严重性：脏读＞不可重读＞幻读
  
### 四种隔离级别

  SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低
  
  1、读未提交：一个事务还没提交时候，它做的变更就能被其他的看到
  
  2、读提交：一个事务提交后，做的变更才能被看到（防止脏读）
  
  3、可重复读：一个事务执行过程中看到的数据，一直跟这个事务启动时候看到的一样（防止不可重复读）
  
  4、串行化：会对记录加锁，在多个事务对这条记录进行读写操作时候，后访问的事务必须等前一个事务全部完成并提交，才能继续执行（防止幻读）
  
  隔离级别：串行化＞可重复读＞读提交＞读未提交
  
  ----------串行化会使得数据库在并发事务时候，性能很差-------------
  
  MySQL的默认隔离级别：可重复读，但是它通过next-key lock 锁（行锁和间隙锁的组合）来锁住记录之间的“间隙”和记录本身，防止其他事务在这个记录之间插入新的记录，这样就避免了幻读现象
  
### 隔离级别的实现方式

  读未提交：直接读就行了

  读提交、可重复读：通过 Read View 来实现

  串行化：加锁，避免并行访问

### Read view

  MVCC：多版本并发控制
  
  可重复读隔离级别：启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View

  读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View
  
### 幻读解决方法（没咋看懂）

  默认隔离级别是可重复读，如果换成了串行化，则性能会很差，但是又得解决幻读：用行锁+间隙锁实现
  
  行锁（记录锁）：锁的是记录本身；
  
  间隙锁：锁的就是两个值之间的空隙，以防止其他事务在这个空隙间插入新的数据，从而避免幻读现象
