--- 整体复习---

# 索引

作用：以空间换时间，加快查找速度，类似于书本的目录，避免一页一页去查找某一页

### BST树、AVL树、B树、B+树

1、BST树：二叉排序树，即左节点 < 根 < 右节点
```
  优点：查询时间比链表快，是O(nlogn)

  缺点：如果插入的节点的值越来越大或者越来越小，则会退化为一条链表
```

2、AVL树：平衡二叉树，在BST树的基础上，其任意节点的左右子树高度差不超过1
```
  优点：不会退化为一条链表，且时间复杂度是O(nlogn)
```

3、B树：多叉树，一般称为 M阶B树，M是分叉个数
```
  --------B树特点-------------

  每个节点的值都是按照递增次序排序的，左小右大
  
  根节点的子节点个数为[2,M]，其他非叶节点的子节点个数为[ceil(M/2),M]，ceil是向上取整
  
  每个非叶节点的值（索引）个数=子节点个数-1

  --------B树优缺点-------------

  优点：B树每一个节点都包含key和value，相比于B+树，离根节点近的元素能更快被查找到

  缺点：不利于范围查找（区间查找），B树查找区间，还是得一个一个查
```

4、B+树
```
  ------------B+树特点---------------

  内部有两种节点：索引节点、叶子节点

  B+树的索引结点只用于索引，所有的数据都保存在B+树的叶子结点中；B树则是所有结点都会保存数据

  B+树的叶子结点都会被连成一条链表，方便区间查找

  B树的所有索引值是不会重复的，而B+树 非叶子结点的索引值，最终一定会全部出现在叶子结点中

  ------------B+树优缺点---------------
  
  优点：
  
  查找区间时，可以直接通过链表进行查找
  
  中间不存储数据，因此相同大小的磁盘空间，可以容纳更多的节点元素
  
  在数据量相同的情况下，B+树的结构比B树更加“矮胖”，因此查询的IO次数也更少

  B树的查找性能并不稳定（最好情况只查询根节点，最坏情况是查找叶子节点），而B+树的每一次查找都是稳定的
```

### MySQL的索引

默认用B+树作为索引类型：

  1、主键索引：如果有主键，用主键当索引，如果没有，选一列不包含null的做索引，都没有，就自动生成一个隐藏自增id列作为索引key；
  
  2、其他索引类型都属于二级索引
  
```
  PS：主键索引：叶节点存放的是实际数据，二级索引：存放的是主键值
  
  select * from product where product_no = '0002';        --这条就是拿二级索引查询
  
  过程：通过二级索引，或者叶子结点中存的主键值，再去主键索引对应的B+树中查询具体数据，即需要查两次
  
  注意：当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引查，如：
  
  select id from product where product_no = '0002';          --这条语句本身查的就是主键值，此时只需要查询一次B+树
  
  上述在二级索引的B+树中就能查询到结果的过程叫：覆盖索引
```
```
  B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，所以B+Tree 相比于 B 树和二叉树来说，最大的优势：在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次
```
