# Redis --键值对（key-value）数据库

https://www.bilibili.com/video/BV1sV4y147Jz/?spm_id_from=333.788&vd_source=07999cb1d010fa9357b6650a0ee711a7

- 高可用的缓存数据库
- 执行命令由单线程负责的，不存在并发竞争的问题


### Redis 与 Memcached

  - 都是基于内存的数据库，一般用来当缓存
  - 都有过期策略
区别：
  - Redis 支持的数据类型更丰富（String、Hash、List、Set、ZSet），而 Memcached 只支持最简单的 key-value 数据类型
  - Redis 支持数据的持久化，Memcached 没有持久化功能，数据全部存在内存之中
  - Redis 原生支持集群模式，Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据
  - Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持

### 为什么用Redis作为MySQL的缓存

主要是因为 Redis 具备「高性能」和「高并发」两种特性

- 高性能：操作 Redis 缓存就是直接操作内存，所以速度相当快

- 高并发：单台设备的 Redis 的 QPS（Query Per Second，每秒钟处理完请求的次数） 是 MySQL 的 10 倍，Redis 单机的 QPS 能轻松破 10w，而 MySQL 单机的 QPS 很难破 1w


### 5大数据类型

这些是 Redis 键值对中值的数据类型，这些对象的底层实现的方式叫数据结构

- String
- Hash
- List
- Set
- ZSet

后续新增数据结构：
- BitMap：二值状态统计的场景
- HyperLogLog：海量数据基数统计的场景，比如百万级网页 UV 计数等
- GEO：存储地理位置信息的场景，比如滴滴叫车
- Stream：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据

### 数据结构

- Redis 的键值对中的 key 就是字符串对象，而 value 可以是字符串对象，也可以是集合数据类型的对象，比如 List 对象、Hash 对象、Set 对象和 Zset 对象

| 字符串String | List | Hash | Set | ZSet |
| :---: | :---: |:---: | :---: | :---: |
| SDS | 双向链表+压缩列表（数据量少时候用）    | 哈希表+压缩列表 | 哈希表+整数集合  | 跳表+压缩链表|
|      |  双向链表 + quicklist（3.2新的）   | 哈希表+  listpack（5.0新的）   |      | 跳表+listpack|




- SDS 简单动态字符串结构（总的来说，Redis 的 SDS 结构在原本字符数组之上，增加了三个元数据）
  - len：记录长度，省去遍历数组找长度的时间，且使得二进制安全
  - alloc：表示分配给数组的空间大小，如果不够，会自动扩展，所以不会出现缓冲区溢出
  - flags：用来表示不同类型的 SDS，为了能灵活保存不同大小的字符串，从而有效节省内存空间，比如，在保存小字符串时，结构头占用空间也比较少
  
  用来解决 C 语言字符串的缺陷

- 双向链表
  - 提供了链表头指针 head、链表尾节点 tail、链表节点数量 len
  - 链表节点可以保存各种不同类型的值
  - 缺点：链表每个节点之间的内存都是不连续的，意味着无法很好利用 CPU 缓存，能很好利用 CPU 缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用 CPU 缓存来加速访问
  - 因为要存前后指针，开销比较大

- 压缩列表
  -  Redis 为了节约内存而开发的
  -  由连续内存块组成的顺序型数据结构
  -  查找复杂度高
  -  存在连锁更新问题：在特殊情况下产生的连续多次空间扩展操作

- 哈希表
  - Redis 采用了「链式哈希」来解决哈希冲突
  - 随着链表长度的增加，查询时间增加 → rehash
  - 在实际使用哈希表时，Redis 定义一个 dict 结构体，这个结构体里定义了两个哈希表，第二个一般分配空间是第一个的两倍，rehash的时候就要用到这个
  - but 迁移数据很废资源
  - 渐进式rehash：每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」 上
  - 负载因子≥1 时候rehash











### 缓存击穿、缓存穿透、缓存雪崩

### RDB

周期性备份是分钟级别的

### AOF持久化

  -------------------------------------**AOF生成快、加载慢，RDB相反（？）**-------------------------

  - 把所有写入命令都写入到AOF文件
  
  - 把要写入的命令，先写入到临时缓冲区aof_buf，再择机写入AOF文件（硬盘里）
  
  - 随着AOF文件越来越大，需要进行压缩：AOF重写，只写入最终数据状态
  
  - 用一个子进程去专门进行重写操作
  
  - 再用一个缓冲区：aof重写缓冲区，在重写的过程中，记录来的新的命令，等重写完成，再把这些命令也写入AOF文件
  
### Redis 哨兵

  - 负责调度主节点、从节点

  - 如果主节点掉线，调度某一个从节点充当主节点

  - 为了及时获得和更新主从节点信息，每隔10秒用info命令向主节点询问都有哪些从节点

  - 每隔10s用ping询问子节点是否掉线（多个哨兵共同确定掉线，才是掉线）

  - 如果主节点掉线，启动故障转移

  - 先选一个新的主节点 → 让其他子节点从新的主节点中同步数据 → 将掉线的主节点改为从节点

  - 选新的主节点的思路：优先级越高的；复制偏移量越大的；断开主节点时间越短的


  
